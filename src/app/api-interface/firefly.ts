/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/api/v1/about': {
    get: operations['getAbout'];
  };
  '/api/v1/about/user': {
    get: operations['getCurrentUser'];
  };
  '/api/v1/accounts': {
    get: operations['listAccount'];
    post: operations['storeAccount'];
  };
  '/api/v1/accounts/{id}': {
    get: operations['getAccount'];
    put: operations['updateAccount'];
    delete: operations['deleteAccount'];
  };
  '/api/v1/accounts/{id}/piggy_banks': {
    get: operations['listPiggyBankByAccount'];
  };
  '/api/v1/accounts/{id}/transactions': {
    get: operations['listTransactionByAccount'];
  };
  '/api/v1/accounts/{id}/attachments': {
    get: operations['listAttachmentByAccount'];
  };
  '/api/v1/attachments': {
    get: operations['listAttachment'];
    post: operations['storeAttachment'];
  };
  '/api/v1/attachments/{id}': {
    get: operations['getAttachment'];
    put: operations['updateAttachment'];
    delete: operations['deleteAttachment'];
  };
  '/api/v1/attachments/{id}/download': {
    get: operations['downloadAttachment'];
  };
  '/api/v1/attachments/{id}/upload': {
    post: operations['uploadAttachment'];
  };
  '/api/v1/autocomplete/accounts': {
    get: operations['getAccountsAC'];
  };
  '/api/v1/autocomplete/bills': {
    get: operations['getBillsAC'];
  };
  '/api/v1/autocomplete/budgets': {
    get: operations['getBudgetsAC'];
  };
  '/api/v1/autocomplete/categories': {
    get: operations['getCategoriesAC'];
  };
  '/api/v1/autocomplete/currencies': {
    get: operations['getCurrenciesAC'];
  };
  '/api/v1/autocomplete/currencies-with-code': {
    get: operations['getCurrenciesCodeAC'];
  };
  '/api/v1/autocomplete/object-groups': {
    get: operations['getObjectGroupsAC'];
  };
  '/api/v1/autocomplete/piggy-banks': {
    get: operations['getPiggiesAC'];
  };
  '/api/v1/autocomplete/piggy-banks-with-balance': {
    get: operations['getPiggiesBalanceAC'];
  };
  '/api/v1/autocomplete/rules': {
    get: operations['getRulesAC'];
  };
  '/api/v1/autocomplete/rule-groups': {
    get: operations['getRuleGroupsAC'];
  };
  '/api/v1/autocomplete/tags': {
    get: operations['getTagAC'];
  };
  '/api/v1/autocomplete/transactions': {
    get: operations['getTransactionsAC'];
  };
  '/api/v1/autocomplete/transactions-with-id': {
    get: operations['getTransactionsIDAC'];
  };
  '/api/v1/autocomplete/transaction-types': {
    get: operations['getTransactionTypesAC'];
  };
  '/api/v1/available_budgets': {
    get: operations['listAvailableBudget'];
    post: operations['storeAvailableBudget'];
  };
  '/api/v1/available_budgets/{id}': {
    get: operations['getAvailableBudget'];
    put: operations['updateAvailableBudget'];
    delete: operations['deleteAvailableBudget'];
  };
  '/api/v1/bills': {
    get: operations['listBill'];
    post: operations['storeBill'];
  };
  '/api/v1/bills/{id}': {
    get: operations['getBill'];
    put: operations['updateBill'];
    delete: operations['deleteBill'];
  };
  '/api/v1/bills/{id}/attachments': {
    get: operations['listAttachmentByBill'];
  };
  '/api/v1/bills/{id}/rules': {
    get: operations['listRuleByBill'];
  };
  '/api/v1/bills/{id}/transactions': {
    get: operations['listTransactionByBill'];
  };
  '/api/v1/budgets': {
    get: operations['listBudget'];
    post: operations['storeBudget'];
  };
  '/api/v1/budgets/{id}': {
    get: operations['getBudget'];
    put: operations['updateBudget'];
    delete: operations['deleteBudget'];
  };
  '/api/v1/budgets/{id}/transactions': {
    get: operations['listTransactionByBudget'];
  };
  '/api/v1/budgets/{id}/limits': {
    get: operations['listBudgetLimitByBudget'];
    post: operations['storeBudgetLimit'];
  };
  '/api/v1/budgets/limits/{id}': {
    get: operations['getBudgetLimit'];
    put: operations['updateBudgetLimit'];
    delete: operations['deleteBudgetLimit'];
  };
  '/api/v1/budgets/limits/{id}/transactions': {
    get: operations['listTransactionByBudgetLimit'];
  };
  '/api/v1/budgets/{id}/attachments': {
    get: operations['listAttachmentByBudget'];
  };
  '/api/v1/categories': {
    get: operations['listCategory'];
    post: operations['storeCategory'];
  };
  '/api/v1/categories/{id}': {
    get: operations['getCategory'];
    put: operations['updateCategory'];
    delete: operations['deleteCategory'];
  };
  '/api/v1/categories/{id}/transactions': {
    get: operations['listTransactionByCategory'];
  };
  '/api/v1/categories/{id}/attachments': {
    get: operations['listAttachmentByCategory'];
  };
  '/api/v1/chart/ab/overview/{id}': {
    get: operations['getChartABOverview'];
  };
  '/api/v1/chart/account/overview': {
    get: operations['getChartAccountOverview'];
  };
  '/api/v1/chart/account/expense': {
    get: operations['getChartAccountExpense'];
  };
  '/api/v1/chart/account/revenue': {
    get: operations['getChartAccountRevenue'];
  };
  '/api/v1/chart/category/overview': {
    get: operations['getChartCategoryOverview'];
  };
  '/api/v1/configuration': {
    get: operations['getConfiguration'];
  };
  '/api/v1/configuration/{name}': {
    post: operations['setConfiguration'];
  };
  '/api/v1/currencies': {
    get: operations['listCurrency'];
    post: operations['storeCurrency'];
  };
  '/api/v1/currencies/{code}/enable': {
    post: operations['enableCurrency'];
  };
  '/api/v1/currencies/{code}/disable': {
    post: operations['disableCurrency'];
  };
  '/api/v1/currencies/{code}/default': {
    post: operations['defaultCurrency'];
  };
  '/api/v1/currencies/{code}': {
    get: operations['getCurrency'];
    put: operations['updateCurrency'];
    delete: operations['deleteCurrency'];
  };
  '/api/v1/currencies/{code}/accounts': {
    get: operations['listAccountByCurrency'];
  };
  '/api/v1/currencies/{code}/available_budgets': {
    get: operations['listAvailableBudgetByCurrency'];
  };
  '/api/v1/currencies/{code}/bills': {
    get: operations['listBillByCurrency'];
  };
  '/api/v1/currencies/{code}/budget_limits': {
    get: operations['listBudgetLimitByCurrency'];
  };
  '/api/v1/currencies/{code}/cer': {
    get: operations['listExchangeRateByCurrency'];
  };
  '/api/v1/currencies/{code}/recurrences': {
    get: operations['listRecurrenceByCurrency'];
  };
  '/api/v1/currencies/{code}/rules': {
    get: operations['listRuleByCurrency'];
  };
  '/api/v1/currencies/{code}/transactions': {
    get: operations['listTransactionByCurrency'];
  };
  '/api/v1/currencies/default': {
    get: operations['getDefaultCurrency'];
  };
  '/api/v1/data/destroy': {
    delete: operations['destroyData'];
  };
  '/api/v1/import/list': {
    get: operations['listImport'];
  };
  '/api/v1/import/{key}': {
    get: operations['getImport'];
  };
  '/api/v1/import/{key}/transactions': {
    get: operations['listTransactionByImport'];
  };
  '/api/v1/link_types': {
    get: operations['listLinkType'];
    post: operations['storeLinkType'];
  };
  '/api/v1/link_types/{id}': {
    get: operations['getLinkType'];
    put: operations['updateLinkType'];
    delete: operations['deleteLinkType'];
  };
  '/api/v1/link_types/{id}/transactions': {
    get: operations['listTransactionByLinkType'];
  };
  '/api/v1/transaction_links': {
    get: operations['listTransactionLink'];
    post: operations['storeTransactionLink'];
  };
  '/api/v1/transaction_links/{id}': {
    get: operations['getTransactionLink'];
    delete: operations['deleteTransactionLink'];
    put: operations['updateTransactionLink'];
  };
  '/api/v1/piggy_banks': {
    get: operations['listPiggyBank'];
    post: operations['storePiggyBank'];
  };
  '/api/v1/piggy_banks/{id}': {
    get: operations['getPiggyBank'];
    put: operations['updatePiggyBank'];
    delete: operations['deletePiggyBank'];
  };
  '/api/v1/piggy_banks/{id}/events': {
    get: operations['listEventByPiggyBank'];
  };
  '/api/v1/piggy_banks/{id}/attachments': {
    get: operations['listAttachmentByPiggyBank'];
  };
  '/api/v1/preferences': {
    get: operations['listPreference'];
  };
  '/api/v1/preferences/{name}': {
    get: operations['getPreference'];
    put: operations['updatePreference'];
  };
  '/api/v1/recurrences': {
    get: operations['listRecurrence'];
    post: operations['storeRecurrence'];
  };
  '/api/v1/recurrences/{id}': {
    get: operations['getRecurrence'];
    put: operations['updateRecurrence'];
    delete: operations['deleteRecurrence'];
  };
  '/api/v1/recurrences/{id}/transactions': {
    get: operations['listTransactionByRecurrence'];
  };
  '/api/v1/recurrences/trigger': {
    post: operations['triggerRecurrence'];
  };
  '/api/v1/rule_groups': {
    get: operations['listRuleGroup'];
    post: operations['storeRuleGroup'];
  };
  '/api/v1/rule_groups/{id}': {
    get: operations['getRuleGroup'];
    put: operations['updateRuleGroup'];
    delete: operations['deleteRuleGroup'];
  };
  '/api/v1/rule_groups/{id}/test': {
    get: operations['testRuleGroup'];
  };
  '/api/v1/rule_groups/{id}/rules': {
    get: operations['listRuleByGroup'];
  };
  '/api/v1/rule_groups/{id}/trigger': {
    post: operations['fireRuleGroup'];
  };
  '/api/v1/rules': {
    get: operations['listRule'];
    post: operations['storeRule'];
  };
  '/api/v1/rules/{id}': {
    get: operations['getRule'];
    put: operations['updateRule'];
    delete: operations['deleteRule'];
  };
  '/api/v1/rules/{id}/test': {
    get: operations['testRule'];
  };
  '/api/v1/rules/{id}/trigger': {
    post: operations['fireRule'];
  };
  '/api/v1/search/transactions': {
    get: operations['searchTransactions'];
  };
  '/api/v1/search/accounts': {
    get: operations['searchAccounts'];
  };
  '/api/v1/summary/basic': {
    get: operations['getBasicSummary'];
  };
  '/api/v1/tag-cloud': {
    get: operations['getTagCloud'];
  };
  '/api/v1/tags': {
    get: operations['listTag'];
    post: operations['storeTag'];
  };
  '/api/v1/tags/{tag}': {
    get: operations['getTag'];
    put: operations['updateTag'];
    delete: operations['deleteTag'];
  };
  '/api/v1/tags/{tag}/transactions': {
    get: operations['listTransactionByTag'];
  };
  '/api/v1/tags/{tag}/attachments': {
    get: operations['listAttachmentByTag'];
  };
  '/api/v1/transactions': {
    get: operations['listTransaction'];
    post: operations['storeTransaction'];
  };
  '/api/v1/transactions/{id}': {
    get: operations['getTransaction'];
    put: operations['updateTransaction'];
    delete: operations['deleteTransaction'];
  };
  '/api/v1/transactions/{id}/attachments': {
    get: operations['listAttachmentByTransaction'];
  };
  '/api/v1/transactions/{id}/piggy_bank_events': {
    get: operations['listEventByTransaction'];
  };
  '/api/v1/transaction-journals/{id}': {
    get: operations['getTransactionByJournal'];
  };
  '/api/v1/users': {
    get: operations['listUser'];
    post: operations['storeUser'];
  };
  '/api/v1/users/{id}': {
    get: operations['getUser'];
    put: operations['updateUser'];
    delete: operations['deleteUser'];
  };
}

export interface operations {
  /** Returns general system information and versions of the (supporting) software. */
  getAbout: {
    responses: {
      /** The available system information */
      200: {
        'application/json': components['schemas']['SystemInfo'];
      };
    };
  };
  /** Returns the currently authenticated user. */
  getCurrentUser: {
    responses: {
      /** The user */
      200: {
        'application/json': components['schemas']['UserSingle'];
      };
    };
  };
  /** This endpoint returns a list of all the accounts owned by the authenticated user. */
  listAccount: {
    parameters: {
      query: {
        /** Page number. The default pagination is per 50 items. */
        page?: number;
        /** A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account's balance on that day. */
        date?: string;
        /** Optional filter on the account type(s) returned */
        type?: components['schemas']['AccountTypeFilter'];
      };
    };
    responses: {
      /** A list of accounts */
      200: {
        'application/json': components['schemas']['AccountArray'];
      };
    };
  };
  /** Creates a new account. The data required can be submitted as a JSON body or as a list of parameters (in key=value pairs, like a webform). */
  storeAccount: {
    requestBody: {
      'application/json': components['schemas']['Account'];
      'application/x-www-form-urlencoded': components['schemas']['Account'];
    };
    responses: {
      /** New account stored, result in response. */
      200: {
        'application/json': components['schemas']['AccountSingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** Returns a single account by its ID. */
  getAccount: {
    parameters: {
      path: {
        /** The ID of the account. */
        id: number;
      };
      query: {
        /** A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account's balance on that day. */
        date?: string;
      };
    };
    responses: {
      /** The requested account */
      200: {
        'application/json': components['schemas']['AccountSingle'];
      };
      /** Account not found */
      404: unknown;
    };
  };
  /** Used to update a single account. All fields that are not submitted will be cleared (set to NULL). The model will tell you which fields are mandatory. */
  updateAccount: {
    parameters: {
      path: {
        /** The ID of the account. */
        id: number;
      };
    };
    requestBody: {
      'application/json': components['schemas']['Account'];
      'application/x-www-form-urlencoded': components['schemas']['Account'];
    };
    responses: {
      /** Updated account stored, result in response */
      200: {
        'application/json': components['schemas']['AccountSingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** Will permanently delete an account. Any associated transactions and piggy banks are ALSO deleted. Cannot be recovered from. */
  deleteAccount: {
    parameters: {
      path: {
        /** The ID of the account. */
        id: number;
      };
    };
    responses: {
      /** Account deleted */
      204: never;
      /** No such account */
      404: unknown;
    };
  };
  /** This endpoint returns a list of all the piggy banks connected to the account. */
  listPiggyBankByAccount: {
    parameters: {
      path: {
        /** The ID of the account. */
        id: number;
      };
      query: {
        /** Page number. The default pagination is per 50 items. */
        page?: number;
      };
    };
    responses: {
      /** A list of piggy banks */
      200: {
        'application/json': components['schemas']['PiggyBankArray'];
      };
    };
  };
  /** This endpoint returns a list of all the transactions connected to the account. */
  listTransactionByAccount: {
    parameters: {
      path: {
        /** The ID of the account. */
        id: number;
      };
      query: {
        /** Page number. The default pagination is per 50 items. */
        page?: number;
        /** Limits the number of results on one page. */
        limit?: number;
        /** A date formatted YYYY-MM-DD. */
        start?: string;
        /** A date formatted YYYY-MM-DD. */
        end?: string;
        /** Optional filter on the transaction type(s) returned. */
        type?: components['schemas']['TransactionTypeFilter'];
      };
    };
    responses: {
      /** A list of transactions */
      200: {
        'application/json': components['schemas']['TransactionArray'];
      };
    };
  };
  /** Lists all attachments. */
  listAttachmentByAccount: {
    parameters: {
      path: {
        /** The ID of the account. */
        id: number;
      };
      query: {
        /** Page number. The default pagination is 50. */
        page?: number;
      };
    };
    responses: {
      /** A list of attachments */
      200: {
        'application/json': components['schemas']['AttachmentArray'];
      };
      /** No such account. */
      404: unknown;
    };
  };
  /** This endpoint lists all attachments. */
  listAttachment: {
    parameters: {
      query: {
        /** Page number. The default pagination is 50. */
        page?: number;
      };
    };
    responses: {
      /** A list of attachments. */
      200: {
        'application/json': components['schemas']['AttachmentArray'];
      };
    };
  };
  /** Creates a new attachment. The data required can be submitted as a JSON body or as a list of parameters. You cannot use this endpoint to upload the actual file data (see below). This endpoint only creates the attachment object. */
  storeAttachment: {
    requestBody: {
      'application/json': components['schemas']['Attachment'];
      'application/x-www-form-urlencoded': components['schemas']['Attachment'];
    };
    responses: {
      /** New attachment stored, result in response. */
      200: {
        'application/json': components['schemas']['AttachmentSingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** Get a single attachment. This endpoint only returns the available metadata for the attachment. Actual file data is handled in two other endpoints (see below). */
  getAttachment: {
    parameters: {
      path: {
        /** The ID of the attachment. */
        id: number;
      };
    };
    responses: {
      /** The requested attachment */
      200: {
        'application/json': components['schemas']['AttachmentSingle'];
      };
      /** Attachment not found */
      404: unknown;
    };
  };
  /** Update the meta data for an existing attachment. This endpoint does not allow you to upload or download data. For that, see below. */
  updateAttachment: {
    parameters: {
      path: {
        /** The ID of the attachment. */
        id: number;
      };
    };
    requestBody: {
      'application/json': components['schemas']['Attachment'];
      'application/x-www-form-urlencoded': components['schemas']['Attachment'];
    };
    responses: {
      /** Updated attachment stored, result in response */
      200: {
        'application/json': components['schemas']['AttachmentSingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** With this endpoint you delete an attachment, including any stored file data. */
  deleteAttachment: {
    parameters: {
      path: {
        /** The ID of the single. */
        id: number;
      };
    };
    responses: {
      /** Attachment deleted. */
      204: never;
      /** No such attachment */
      404: unknown;
    };
  };
  /** This endpoint allows you to download the binary content of a transaction. It will be sent to you as a download, using the content type "application/octet-stream" and content disposition "attachment; filename=example.pdf". */
  downloadAttachment: {
    parameters: {
      path: {
        /** The ID of the attachment. */
        id: number;
      };
    };
    responses: {
      /** The requested attachment */
      200: {
        'application/octet-stream': string;
      };
      /** File not found */
      404: unknown;
    };
  };
  /** Use this endpoint to upload (and possible overwrite) the file contents of an attachment. Simply put the entire file in the body as binary data. */
  uploadAttachment: {
    parameters: {
      path: {
        /** The ID of the attachment. */
        id: number;
      };
    };
    requestBody: {
      'application/octet-stream': string;
    };
    responses: {
      /** Upload was a success */
      204: never;
      /** File not found */
      404: unknown;
      /** Upload invalid or empty file. */
      422: unknown;
    };
  };
  getAccountsAC: {
    parameters: {
      query: {
        /** The autocomplete search query. */
        query?: string;
        /** The autocomplete number of items returned */
        limit?: number;
        /** For asset accounts, returns the balance on this date. */
        date?: string;
        /** Optional filter on the account type(s) returned */
        type?: components['schemas']['AccountTypeFilter'];
      };
    };
    responses: {
      /** A list of accounts with very basic information. */
      200: {
        'application/json': components['schemas']['AutocompleteAccountArray'];
      };
    };
  };
  getBillsAC: {
    parameters: {
      query: {
        /** The autocomplete search query. */
        query?: string;
        /** The autocomplete number of items returned */
        limit?: number;
      };
    };
    responses: {
      /** A list of bills with very basic information. */
      200: {
        'application/json': components['schemas']['AutocompleteBillArray'];
      };
    };
  };
  getBudgetsAC: {
    parameters: {
      query: {
        /** The autocomplete search query. */
        query?: string;
        /** The autocomplete number of items returned */
        limit?: number;
      };
    };
    responses: {
      /** A list of budgets with very basic information. */
      200: {
        'application/json': components['schemas']['AutocompleteBudgetArray'];
      };
    };
  };
  getCategoriesAC: {
    parameters: {
      query: {
        /** The autocomplete search query. */
        query?: string;
        /** The autocomplete number of items returned */
        limit?: number;
      };
    };
    responses: {
      /** A list of categories with very basic information. */
      200: {
        'application/json': components['schemas']['AutocompleteCategoryArray'];
      };
    };
  };
  getCurrenciesAC: {
    parameters: {
      query: {
        /** The autocomplete search query. */
        query?: string;
        /** The autocomplete number of items returned */
        limit?: number;
      };
    };
    responses: {
      /** A list of currencies with very basic information. */
      200: {
        'application/json': components['schemas']['AutocompleteCurrencyArray'];
      };
    };
  };
  getCurrenciesCodeAC: {
    parameters: {
      query: {
        /** The autocomplete search query. */
        query?: string;
        /** The autocomplete number of items returned */
        limit?: number;
      };
    };
    responses: {
      /** A list of currencies with very basic information and the currency code between brackets. */
      200: {
        'application/json': components['schemas']['AutocompleteCurrencyCodeArray'];
      };
    };
  };
  getObjectGroupsAC: {
    parameters: {
      query: {
        /** The autocomplete search query. */
        query?: string;
        /** The autocomplete number of items returned */
        limit?: number;
      };
    };
    responses: {
      /** A list of object groups with very basic information. */
      200: {
        'application/json': components['schemas']['AutocompleteObjectGroupArray'];
      };
    };
  };
  getPiggiesAC: {
    parameters: {
      query: {
        /** The autocomplete search query. */
        query?: string;
        /** The autocomplete number of items returned */
        limit?: number;
      };
    };
    responses: {
      /** A list of piggy banks with very basic information. */
      200: {
        'application/json': components['schemas']['AutocompletePiggyArray'];
      };
    };
  };
  getPiggiesBalanceAC: {
    parameters: {
      query: {
        /** The autocomplete search query. */
        query?: string;
        /** The autocomplete number of items returned */
        limit?: number;
      };
    };
    responses: {
      /** A list of piggy banks with very basic balance information. */
      200: {
        'application/json': components['schemas']['AutocompletePiggyBalanceArray'];
      };
    };
  };
  getRulesAC: {
    parameters: {
      query: {
        /** The autocomplete search query. */
        query?: string;
        /** The autocomplete number of items returned */
        limit?: number;
      };
    };
    responses: {
      /** A list of rules with very basic information. */
      200: {
        'application/json': components['schemas']['AutocompleteRuleArray'];
      };
    };
  };
  getRuleGroupsAC: {
    parameters: {
      query: {
        /** The autocomplete search query. */
        query?: string;
        /** The autocomplete number of items returned */
        limit?: number;
      };
    };
    responses: {
      /** A list of rule groups with very basic information. */
      200: {
        'application/json': components['schemas']['AutocompleteRuleGroupArray'];
      };
    };
  };
  getTagAC: {
    parameters: {
      query: {
        /** The autocomplete search query. */
        query?: string;
        /** The autocomplete number of items returned */
        limit?: number;
      };
    };
    responses: {
      /** A list of tags with very basic information. */
      200: {
        'application/json': components['schemas']['AutocompleteTagArray'];
      };
    };
  };
  getTransactionsAC: {
    parameters: {
      query: {
        /** The autocomplete search query. */
        query?: string;
        /** The autocomplete number of items returned */
        limit?: number;
      };
    };
    responses: {
      /** A list of transaction descriptions with very basic information. */
      200: {
        'application/json': components['schemas']['AutocompleteTransactionArray'];
      };
    };
  };
  getTransactionsIDAC: {
    parameters: {
      query: {
        /** The autocomplete search query. */
        query?: string;
        /** The autocomplete number of items returned */
        limit?: number;
      };
    };
    responses: {
      /** A list of transactions with very basic information. */
      200: {
        'application/json': components['schemas']['AutocompleteTransactionIDArray'];
      };
    };
  };
  getTransactionTypesAC: {
    parameters: {
      query: {
        /** The autocomplete search query. */
        query?: string;
        /** The autocomplete number of items returned */
        limit?: number;
      };
    };
    responses: {
      /** A list of transaction types with very basic information. */
      200: {
        'application/json': components['schemas']['AutocompleteTransactionTypeArray'];
      };
    };
  };
  /** Firefly III allows users to set the amount that is available to be budgeted in so-called "available budgets". For example, the user could have 1200,- available to be divided during the coming month. This amount is used on the /budgets page. This endpoint returns all of these amounts and the periods for which they are set. */
  listAvailableBudget: {
    parameters: {
      query: {
        /** Page number. The default pagination is 50. */
        page?: number;
        /** A date formatted YYYY-MM-DD. */
        start?: string;
        /** A date formatted YYYY-MM-DD. */
        end?: string;
      };
    };
    responses: {
      /** A list of available budget amounts. */
      200: {
        'application/json': components['schemas']['AvailableBudgetArray'];
      };
    };
  };
  /** Creates a new available budget for a specified period. The data required can be submitted as a JSON body or as a list of parameters. */
  storeAvailableBudget: {
    requestBody: {
      'application/json': components['schemas']['AvailableBudget'];
      'application/x-www-form-urlencoded': components['schemas']['AvailableBudget'];
    };
    responses: {
      /** New available budget stored, result in response. */
      200: {
        'application/json': components['schemas']['AvailableBudgetSingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** Get a single available budget, by ID. */
  getAvailableBudget: {
    parameters: {
      path: {
        /** The ID of the available budget. */
        id: number;
      };
    };
    responses: {
      /** The requested available budget */
      200: {
        'application/json': components['schemas']['AvailableBudgetSingle'];
      };
      /** AvailableBudget not found */
      404: unknown;
    };
  };
  /** Update existing available budget. */
  updateAvailableBudget: {
    parameters: {
      path: {
        /** The ID of the object.X */
        id: number;
      };
    };
    requestBody: {
      'application/json': components['schemas']['AvailableBudget'];
      'application/x-www-form-urlencoded': components['schemas']['AvailableBudget'];
    };
    responses: {
      /** Updated available budget stored, result in response */
      200: {
        'application/json': components['schemas']['AvailableBudgetSingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** Delete an available budget. Not much more to say. */
  deleteAvailableBudget: {
    parameters: {
      path: {
        /** The ID of the available budget. */
        id: number;
      };
    };
    responses: {
      /** Available budget deleted. */
      204: never;
      /** No such available budget. */
      404: unknown;
    };
  };
  /** This endpoint will list all the user's bills. */
  listBill: {
    parameters: {
      query: {
        /** Page number. The default pagination is 50. */
        page?: number;
        /** A date formatted YYYY-MM-DD. If it is are added to the request, Firefly III will calculate the appropriate payment and paid dates. */
        start?: string;
        /** A date formatted YYYY-MM-DD. If it is added to the request, Firefly III will calculate the appropriate payment and paid dates. */
        end?: string;
      };
    };
    responses: {
      /** A list of bills */
      200: {
        'application/json': components['schemas']['BillArray'];
      };
    };
  };
  /** Creates a new bill. The data required can be submitted as a JSON body or as a list of parameters. */
  storeBill: {
    requestBody: {
      'application/json': components['schemas']['Bill'];
      'application/x-www-form-urlencoded': components['schemas']['Bill'];
    };
    responses: {
      /** New bill stored, result in response. */
      200: {
        'application/json': components['schemas']['BillSingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** Get a single bill. */
  getBill: {
    parameters: {
      path: {
        /** The ID of the bill. */
        id: number;
      };
      query: {
        /** A date formatted YYYY-MM-DD. If it is are added to the request, Firefly III will calculate the appropriate payment and paid dates. */
        start?: string;
        /** A date formatted YYYY-MM-DD. If it is added to the request, Firefly III will calculate the appropriate payment and paid dates. */
        end?: string;
      };
    };
    responses: {
      /** The requested bill */
      200: {
        'application/json': components['schemas']['BillSingle'];
      };
      /** Bill not found */
      404: unknown;
    };
  };
  /** Update existing bill. */
  updateBill: {
    parameters: {
      path: {
        /** The ID of the bill. */
        id: number;
      };
    };
    requestBody: {
      'application/json': components['schemas']['Bill'];
      'application/x-www-form-urlencoded': components['schemas']['Bill'];
    };
    responses: {
      /** Updated bill stored, result in response */
      200: {
        'application/json': components['schemas']['BillSingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** Delete a bill. This will not delete any associated rules. Will not remove associated transactions. WILL remove all associated attachments. */
  deleteBill: {
    parameters: {
      path: {
        /** The ID of the bill. */
        id: number;
      };
    };
    responses: {
      /** Bill deleted. */
      204: never;
      /** No such bill */
      404: unknown;
    };
  };
  /** This endpoint will list all attachments linked to the bill. */
  listAttachmentByBill: {
    parameters: {
      path: {
        /** The ID of the bill. */
        id: number;
      };
      query: {
        /** Page number. The default pagination is 50. */
        page?: number;
      };
    };
    responses: {
      /** A list of attachments */
      200: {
        'application/json': components['schemas']['AttachmentArray'];
      };
    };
  };
  /** This endpoint will list all rules that have an action to set the bill to this bill. */
  listRuleByBill: {
    parameters: {
      path: {
        /** The ID of the bill. */
        id: number;
      };
    };
    responses: {
      /** A list of rules */
      200: {
        'application/json': components['schemas']['RuleArray'];
      };
    };
  };
  /** This endpoint will list all transactions linked to this bill. */
  listTransactionByBill: {
    parameters: {
      path: {
        /** The ID of the bill. */
        id: number;
      };
      query: {
        /** A date formatted YYYY-MM-DD. */
        start?: string;
        /** A date formatted YYYY-MM-DD. */
        end?: string;
        /** Optional filter on the transaction type(s) returned */
        type?: components['schemas']['TransactionTypeFilter'];
      };
    };
    responses: {
      /** A list of transactions */
      200: {
        'application/json': components['schemas']['TransactionArray'];
      };
    };
  };
  /** List all the budgets the user has made. If the start date and end date are submitted as well, the "spent" array will be updated accordingly. */
  listBudget: {
    parameters: {
      query: {
        /** Page number. The default pagination is 50. */
        page?: number;
        /** A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end. */
        start?: string;
        /** A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end. */
        end?: string;
      };
    };
    responses: {
      /** A list of budgets. */
      200: {
        'application/json': components['schemas']['BudgetArray'];
      };
    };
  };
  /** Creates a new budget. The data required can be submitted as a JSON body or as a list of parameters. */
  storeBudget: {
    requestBody: {
      'application/json': components['schemas']['Budget'];
      'application/x-www-form-urlencoded': components['schemas']['Budget'];
    };
    responses: {
      /** New budget stored, result in response. */
      200: {
        'application/json': components['schemas']['BudgetSingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** Get a single budget. If the start date and end date are submitted as well, the "spent" array will be updated accordingly. */
  getBudget: {
    parameters: {
      path: {
        /** The ID of the requested budget. */
        id: number;
      };
      query: {
        /** A date formatted YYYY-MM-DD, to get info on how much the user has spent. */
        start?: string;
        /** A date formatted YYYY-MM-DD, to get info on how much the user has spent. */
        end?: string;
      };
    };
    responses: {
      /** The requested budget */
      200: {
        'application/json': components['schemas']['BudgetSingle'];
      };
      /** Budget not found. */
      404: unknown;
    };
  };
  /** Update existing budget. This endpoint cannot be used to set budget amount limits. */
  updateBudget: {
    parameters: {
      path: {
        /** The ID of the budget. */
        id: number;
      };
    };
    requestBody: {
      'application/json': components['schemas']['Budget'];
      'application/x-www-form-urlencoded': components['schemas']['Budget'];
    };
    responses: {
      /** Updated budget stored, result in response */
      200: {
        'application/json': components['schemas']['BudgetSingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** Delete a budget. Transactions will not be deleted. */
  deleteBudget: {
    parameters: {
      path: {
        /** The ID of the budget. */
        id: number;
      };
    };
    responses: {
      /** Budget deleted. */
      204: never;
      /** No such budget */
      404: unknown;
    };
  };
  /** Get all transactions linked to a budget, possibly limited by start and end */
  listTransactionByBudget: {
    parameters: {
      path: {
        /** The ID of the budget. */
        id: number;
      };
      query: {
        /** Limits the number of results on one page. */
        limit?: number;
        /** Page number. The default pagination is 50. */
        page?: number;
        /** A date formatted YYYY-MM-DD. */
        start?: string;
        /** A date formatted YYYY-MM-DD. */
        end?: string;
        /** Optional filter on the transaction type(s) returned */
        type?: components['schemas']['TransactionTypeFilter'];
      };
    };
    responses: {
      /** A list of transactions. */
      200: {
        'application/json': components['schemas']['TransactionArray'];
      };
    };
  };
  /** Get all budget limits for this budget and the money spent, and money left. You can limit the list by submitting a date range as well. The "spent" array for each budget limit is NOT influenced by the start and end date of your query, but by the start and end date of the budget limit itself. */
  listBudgetLimitByBudget: {
    parameters: {
      path: {
        /** The ID of the requested budget. */
        id: number;
      };
      query: {
        /** A date formatted YYYY-MM-DD. */
        start?: string;
        /** A date formatted YYYY-MM-DD. */
        end?: string;
      };
    };
    responses: {
      /** A list of budget limits applicable to this budget. */
      200: {
        'application/json': components['schemas']['BudgetLimitArray'];
      };
    };
  };
  /** Store a new budget limit. */
  storeBudgetLimit: {
    parameters: {
      path: {
        /** The ID of the budget. */
        id: number;
      };
    };
    requestBody: {
      'application/json': components['schemas']['BudgetLimit'];
      'application/x-www-form-urlencoded': components['schemas']['BudgetLimit'];
    };
    responses: {
      /** New budget limit stored, result in response. */
      200: {
        'application/json': components['schemas']['BudgetLimitSingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  getBudgetLimit: {
    parameters: {
      path: {
        /** The ID of the requested budget limit. */
        id: number;
      };
    };
    responses: {
      /** The requested budget limit */
      200: {
        'application/json': components['schemas']['BudgetLimitSingle'];
      };
      /** Budget limit not found. */
      404: unknown;
    };
  };
  /** Update existing budget limit. */
  updateBudgetLimit: {
    parameters: {
      path: {
        /** The ID of the requested budget limit. The budget limit MUST be associated to the budget ID. */
        id: number;
      };
    };
    requestBody: {
      'application/json': components['schemas']['BudgetLimit'];
      'application/x-www-form-urlencoded': components['schemas']['BudgetLimit'];
    };
    responses: {
      /** Updated budget limit stored, result in response */
      200: {
        'application/json': components['schemas']['BudgetLimitSingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** Delete a budget limit. */
  deleteBudgetLimit: {
    parameters: {
      path: {
        /** The ID of the requested budget limit. */
        id: number;
      };
    };
    responses: {
      /** Budget limit deleted. */
      204: never;
      /** No such budget limit */
      404: unknown;
    };
  };
  /** List all the transactions within one budget limit. The start and end date are dictated by the budget limit. */
  listTransactionByBudgetLimit: {
    parameters: {
      path: {
        /** The ID of the requested budget limit. */
        id: number;
      };
      query: {
        /** Page number. The default pagination is 50. */
        page?: number;
        /** Optional filter on the transaction type(s) returned */
        type?: components['schemas']['TransactionTypeFilter'];
      };
    };
    responses: {
      /** A list of transactions. */
      200: {
        'application/json': components['schemas']['TransactionArray'];
      };
    };
  };
  /** Lists all attachments. */
  listAttachmentByBudget: {
    parameters: {
      path: {
        /** The ID of the budget. */
        id: number;
      };
      query: {
        /** Page number. The default pagination is 50. */
        page?: number;
      };
    };
    responses: {
      /** A list of attachments */
      200: {
        'application/json': components['schemas']['AttachmentArray'];
      };
      /** No such budget. */
      404: unknown;
    };
  };
  /** List all categories. */
  listCategory: {
    parameters: {
      query: {
        /** Page number. The default pagination is 50. */
        page?: number;
      };
    };
    responses: {
      /** A list of categories. */
      200: {
        'application/json': components['schemas']['CategoryArray'];
      };
    };
  };
  /** Creates a new category. The data required can be submitted as a JSON body or as a list of parameters. */
  storeCategory: {
    requestBody: {
      'application/json': components['schemas']['Category'];
      'application/x-www-form-urlencoded': components['schemas']['Category'];
    };
    responses: {
      /** New category stored, result in response. */
      200: {
        'application/json': components['schemas']['CategorySingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** Get a single category. */
  getCategory: {
    parameters: {
      path: {
        /** The ID of the category. */
        id: number;
      };
      query: {
        /** A date formatted YYYY-MM-DD, to show spent and earned info. */
        start?: string;
        /** A date formatted YYYY-MM-DD, to show spent and earned info. */
        end?: string;
      };
    };
    responses: {
      /** The requested category */
      200: {
        'application/json': components['schemas']['CategorySingle'];
      };
      /** Category not found */
      404: unknown;
    };
  };
  /** Update existing category. */
  updateCategory: {
    parameters: {
      path: {
        /** The ID of the category. */
        id: number;
      };
    };
    requestBody: {
      'application/json': components['schemas']['Category'];
      'application/x-www-form-urlencoded': components['schemas']['Category'];
    };
    responses: {
      /** Updated category stored, result in response */
      200: {
        'application/json': components['schemas']['CategorySingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** Delete a category. Transactions will not be removed. */
  deleteCategory: {
    parameters: {
      path: {
        /** The ID of the category. */
        id: number;
      };
    };
    responses: {
      /** Category deleted. */
      204: never;
      /** No such category. */
      404: unknown;
    };
  };
  /** List all transactions in a category, optionally limited to the date ranges specified. */
  listTransactionByCategory: {
    parameters: {
      path: {
        /** The ID of the category. */
        id: number;
      };
      query: {
        /** Page number. The default pagination is per 50. */
        page?: number;
        /** A date formatted YYYY-MM-DD, to limit the result list. */
        start?: string;
        /** A date formatted YYYY-MM-DD, to limit the result list. */
        end?: string;
        /** Optional filter on the transaction type(s) returned */
        type?: components['schemas']['TransactionTypeFilter'];
      };
    };
    responses: {
      /** A list of transactions. */
      200: {
        'application/json': components['schemas']['TransactionArray'];
      };
    };
  };
  /** Lists all attachments. */
  listAttachmentByCategory: {
    parameters: {
      path: {
        /** The ID of the category. */
        id: number;
      };
      query: {
        /** Page number. The default pagination is 50. */
        page?: number;
      };
    };
    responses: {
      /** A list of attachments */
      200: {
        'application/json': components['schemas']['AttachmentArray'];
      };
      /** No such category. */
      404: unknown;
    };
  };
  /** This endpoint returns the data required to generate a pie chart for the available budget. */
  getChartABOverview: {
    parameters: {
      path: {
        /** The ID of the available budget. */
        id: number;
      };
      query: {
        /** A date formatted YYYY-MM-DD. */
        start: string;
        /** A date formatted YYYY-MM-DD. */
        end: string;
      };
    };
    responses: {
      /** Pie chart oriented chart information. Check out the model for more details. Each entry is a piece of the pie in the chart. */
      200: {
        'application/json': components['schemas']['ChartLine'];
      };
    };
  };
  /** This endpoint returns the data required to generate a chart with basic asset account balance information. */
  getChartAccountOverview: {
    parameters: {
      query: {
        /** A date formatted YYYY-MM-DD. */
        start: string;
        /** A date formatted YYYY-MM-DD. */
        end: string;
      };
    };
    responses: {
      /** Line chart oriented chart information. Check out the model for more details. Each entry is a line (or bar) in the chart. */
      200: {
        'application/json': components['schemas']['ChartLine'];
      };
    };
  };
  /** This endpoint returns the data required to generate a chart that shows the user how much they've spent on their expense accounts. */
  getChartAccountExpense: {
    parameters: {
      query: {
        /** A date formatted YYYY-MM-DD. */
        start: string;
        /** A date formatted YYYY-MM-DD. */
        end: string;
      };
    };
    responses: {
      /** Bar chart oriented chart information. Check out the model for more details. Each entry is a line (or bar) in the chart. */
      200: {
        'application/json': components['schemas']['ChartBar'];
      };
    };
  };
  /** This endpoint returns the data required to generate a chart that shows the user how much they've earned from their revenue accounts. */
  getChartAccountRevenue: {
    parameters: {
      query: {
        /** A date formatted YYYY-MM-DD. */
        start: string;
        /** A date formatted YYYY-MM-DD. */
        end: string;
      };
    };
    responses: {
      /** Bar chart oriented chart information. Check out the model for more details. Each entry is a line (or bar) in the chart. */
      200: {
        'application/json': components['schemas']['ChartBar'];
      };
    };
  };
  /** This endpoint returns the data required to generate a bar chart for the expenses and incomes on the users categories. */
  getChartCategoryOverview: {
    parameters: {
      query: {
        /** A date formatted YYYY-MM-DD. */
        start: string;
        /** A date formatted YYYY-MM-DD. */
        end: string;
      };
    };
    responses: {
      /** Bar chart oriented chart information. Check out the model for more details. Each entry is a set of bars in the chart. */
      200: {
        'application/json': components['schemas']['ChartLine'];
      };
    };
  };
  /** Get system configuration */
  getConfiguration: {
    responses: {
      /** System configuration */
      200: {
        'application/json': components['schemas']['Configuration'];
      };
    };
  };
  /** Set a single config value. */
  setConfiguration: {
    parameters: {
      path: {
        /** The configuration value name. */
        name: 'is_demo_site' | 'last_update_check' | 'single_user_mode';
      };
    };
    requestBody: {
      'application/x-www-form-urlencoded': components['schemas']['ConfigurationUpdate'];
      'application/json': components['schemas']['ConfigurationUpdate'];
    };
    responses: {
      /** New config stored, result in response. */
      200: {
        'application/json': components['schemas']['Configuration'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** List all currencies. */
  listCurrency: {
    parameters: {
      query: {
        /** Page number. The default pagination is 50. */
        page?: number;
      };
    };
    responses: {
      /** A list of currencies. */
      200: {
        'application/json': components['schemas']['CurrencyArray'];
      };
    };
  };
  /** Creates a new currency. The data required can be submitted as a JSON body or as a list of parameters. */
  storeCurrency: {
    requestBody: {
      'application/json': components['schemas']['Currency'];
      'application/x-www-form-urlencoded': components['schemas']['Currency'];
    };
    responses: {
      /** New currency stored, result in response. */
      200: {
        'application/json': components['schemas']['CurrencySingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** Enable a single currency. */
  enableCurrency: {
    parameters: {
      path: {
        /** The currency code. */
        code: string;
      };
    };
    responses: {
      /** Currency was enabled. */
      204: {
        'application/json': components['schemas']['CurrencySingle'];
      };
    };
  };
  /** Disable a currency. */
  disableCurrency: {
    parameters: {
      path: {
        /** The currency code. */
        code: number;
      };
    };
    responses: {
      /** Currency was disabled. */
      204: {
        'application/json': components['schemas']['CurrencySingle'];
      };
      /** Currency cannot be disabled, because it is still in use. */
      409: unknown;
    };
  };
  /** Make this currency the default currency. If the currency is not enabled, it will be enabled as well. */
  defaultCurrency: {
    parameters: {
      path: {
        /** The currency code. */
        code: string;
      };
    };
    responses: {
      /** Currency has been made the default currency. */
      204: {
        'application/json': components['schemas']['CurrencySingle'];
      };
    };
  };
  /** Get a single currency. */
  getCurrency: {
    parameters: {
      path: {
        /** The currency code. */
        code: string;
      };
    };
    responses: {
      /** The requested currency */
      200: {
        'application/json': components['schemas']['CurrencySingle'];
      };
      /** Currency not found */
      404: unknown;
    };
  };
  /** Update existing currency. */
  updateCurrency: {
    parameters: {
      path: {
        /** The currency code. */
        code: string;
      };
    };
    requestBody: {
      'application/json': components['schemas']['Currency'];
      'application/x-www-form-urlencoded': components['schemas']['Currency'];
    };
    responses: {
      /** Updated currency stored, result in response */
      200: {
        'application/json': components['schemas']['CurrencySingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** Delete a currency. */
  deleteCurrency: {
    parameters: {
      path: {
        /** The currency code. */
        code: string;
      };
    };
    responses: {
      /** Currency deleted. */
      204: never;
      /** No such currency */
      404: unknown;
    };
  };
  /** List all accounts with this currency. */
  listAccountByCurrency: {
    parameters: {
      path: {
        /** The currency code. */
        code: string;
      };
      query: {
        /** Page number. The default pagination is 50. */
        page?: number;
        /** A date formatted YYYY-MM-DD. When added to the request, Firefly III will show the account's balance on that day. */
        date?: string;
        /** Optional filter on the account type(s) returned */
        type?: components['schemas']['AccountTypeFilter'];
      };
    };
    responses: {
      /** A list of accounts */
      200: {
        'application/json': components['schemas']['AccountArray'];
      };
    };
  };
  /** List all available budgets with this currency. */
  listAvailableBudgetByCurrency: {
    parameters: {
      path: {
        /** The currency code. */
        code: string;
      };
      query: {
        /** Page number. The default pagination is 50 */
        page?: number;
      };
    };
    responses: {
      /** A list of available budgets */
      200: {
        'application/json': components['schemas']['AvailableBudgetArray'];
      };
    };
  };
  /** List all bills with this currency. */
  listBillByCurrency: {
    parameters: {
      path: {
        /** The currency code. */
        code: string;
      };
      query: {
        /** Page number. The default pagination is 50. */
        page?: number;
      };
    };
    responses: {
      /** A list of bills. */
      200: {
        'application/json': components['schemas']['BillArray'];
      };
    };
  };
  /** List all budget limits with this currency */
  listBudgetLimitByCurrency: {
    parameters: {
      path: {
        /** The currency code. */
        code: string;
      };
      query: {
        /** Page number. The default pagination is 50. */
        page?: number;
        /** Start date for the budget limit list. */
        start?: string;
        /** End date for the budget limit list. */
        end?: string;
      };
    };
    responses: {
      /** A list of budget limits. */
      200: {
        'application/json': components['schemas']['BudgetLimitArray'];
      };
    };
  };
  /** List all known exchange rates. */
  listExchangeRateByCurrency: {
    parameters: {
      path: {
        /** The currency code. */
        code: string;
      };
      query: {
        /** Page number. The default pagination is 50. */
        page?: number;
        /** The date of which you want to know the exchange rate */
        date?: string;
        /** Use this instead of the date parameter to search for a range of currency exchange values. */
        start?: string;
        /** Use this instead of the date parameter to search for a range of currency exchange values. */
        end?: string;
      };
    };
    responses: {
      /** A list of exchange rates */
      200: {
        'application/json': components['schemas']['ExchangeRateArray'];
      };
    };
  };
  /** List all recurring transactions with this currency. */
  listRecurrenceByCurrency: {
    parameters: {
      path: {
        /** The currency code. */
        code: string;
      };
      query: {
        /** Page number. The default pagination is 50. */
        page?: number;
      };
    };
    responses: {
      /** A list of recurring transactions */
      200: {
        'application/json': components['schemas']['RecurrenceArray'];
      };
    };
  };
  /** List all rules with this currency. */
  listRuleByCurrency: {
    parameters: {
      path: {
        /** The currency code. */
        code: string;
      };
      query: {
        /** Page number. The default pagination per 50. */
        page?: number;
      };
    };
    responses: {
      /** A list of rules */
      200: {
        'application/json': components['schemas']['RuleArray'];
      };
    };
  };
  /** List all transactions with this currency. */
  listTransactionByCurrency: {
    parameters: {
      path: {
        /** The currency code. */
        code: string;
      };
      query: {
        /** Page number. The default pagination is per 50. */
        page?: number;
        /** A date formatted YYYY-MM-DD, to limit the list of transactions. */
        start_date?: string;
        /** A date formatted YYYY-MM-DD, to limit the list of transactions. */
        end_date?: string;
        /** Optional filter on the transaction type(s) returned */
        type?: components['schemas']['TransactionTypeFilter'];
      };
    };
    responses: {
      /** A list of transactions. */
      200: {
        'application/json': components['schemas']['TransactionArray'];
      };
    };
  };
  /** Get the user's default currency. */
  getDefaultCurrency: {
    responses: {
      /** The default currency */
      200: {
        'application/json': components['schemas']['CurrencySingle'];
      };
    };
  };
  /**
   * A call to this endpoint permanently destroys the requested data type. Use it with care and always with user permission.
   * The demo user is incapable of using this endpoint.
   */
  destroyData: {
    parameters: {
      query: {
        /** The type of data that you wish to destroy. */
        objects: components['schemas']['DataDestroyObject'];
      };
    };
    responses: {
      /** Empty response when data has been destroyed. */
      204: never;
      /** Internal error, or user is unauthorized to destroy data. */
      500: unknown;
    };
  };
  /** List all imports */
  listImport: {
    parameters: {
      query: {
        /** Page number. The default pagination is per 50 items. */
        page?: number;
      };
    };
    responses: {
      /** A list of import jobs. */
      200: {
        'application/json': components['schemas']['ImportJobArray'];
      };
    };
  };
  /** Show info on single import. */
  getImport: {
    parameters: {
      path: {
        /** The job key of an import job. */
        key: string;
      };
    };
    responses: {
      /** The requested import job */
      200: {
        'application/json': components['schemas']['ImportJobSingle'];
      };
      /** Import job not found */
      404: unknown;
    };
  };
  /** See summary */
  listTransactionByImport: {
    parameters: {
      path: {
        /** The key of the import job */
        key: string;
      };
      query: {
        /** Page number. The default pagination is 50. */
        page?: number;
        /** A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive). */
        start?: string;
        /** A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive). */
        end?: string;
        /** Optional filter on the transaction type(s) returned. */
        type?: components['schemas']['TransactionTypeFilter'];
      };
    };
    responses: {
      /** A list of transactions. */
      200: {
        'application/json': components['schemas']['TransactionArray'];
      };
    };
  };
  /** List all the link types the system has. These include the default ones as well as any new ones. */
  listLinkType: {
    parameters: {
      query: {
        /** Page number. The default pagination is 50 items. */
        page?: number;
      };
    };
    responses: {
      /** A list of link types. */
      200: {
        'application/json': components['schemas']['LinkTypeArray'];
      };
    };
  };
  /** Creates a new link type. The data required can be submitted as a JSON body or as a list of parameters (in key=value pairs, like a webform). */
  storeLinkType: {
    requestBody: {
      'application/json': components['schemas']['LinkType'];
      'application/x-www-form-urlencoded': components['schemas']['LinkType'];
    };
    responses: {
      /** New link type stored, result in response. */
      200: {
        'application/json': components['schemas']['LinkTypeSingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** Returns a single link type by its ID. */
  getLinkType: {
    parameters: {
      path: {
        /** The ID of the link type. */
        id: number;
      };
    };
    responses: {
      /** The requested link type */
      200: {
        'application/json': components['schemas']['LinkTypeSingle'];
      };
      /** Link type not found. */
      404: unknown;
    };
  };
  /** Used to update a single link type. All fields that are not submitted will be cleared (set to NULL). The model will tell you which fields are mandatory. You cannot update some of the system provided link types, indicated by the editable=false flag when you list it. */
  updateLinkType: {
    parameters: {
      path: {
        /** The ID of the link type. */
        id: number;
      };
    };
    requestBody: {
      'application/json': components['schemas']['LinkType'];
      'application/x-www-form-urlencoded': components['schemas']['LinkType'];
    };
    responses: {
      /** Updated link type stored, result in response */
      200: {
        'application/json': components['schemas']['LinkTypeSingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
      /** Cannot delete this link type. */
      500: unknown;
    };
  };
  /** Will permanently delete a link type. The links between transactions will be removed. The transactions themselves remain. You cannot delete some of the system provided link types, indicated by the editable=false flag when you list it. */
  deleteLinkType: {
    parameters: {
      path: {
        /** The ID of the link type. */
        id: number;
      };
    };
    responses: {
      /** Link type deleted */
      204: never;
      /** No such link type */
      404: unknown;
      /** Cannot delete this link type. */
      500: unknown;
    };
  };
  /** List all transactions under this link type, both the inward and outward transactions. */
  listTransactionByLinkType: {
    parameters: {
      path: {
        /** The ID of the link type. */
        id: number;
      };
      query: {
        /** Page number. The default pagination is per 50 items. */
        page?: number;
        /** A date formatted YYYY-MM-DD, to limit the results. */
        start?: string;
        /** A date formatted YYYY-MM-DD, to limit the results. */
        end?: string;
        /** Optional filter on the transaction type(s) returned. */
        type?: components['schemas']['TransactionTypeFilter'];
      };
    };
    responses: {
      /** A list of transactions */
      200: {
        'application/json': components['schemas']['TransactionArray'];
      };
    };
  };
  /** List all the transaction links. */
  listTransactionLink: {
    parameters: {
      query: {
        /** Page number. The default pagination is per 50 items. */
        page?: number;
      };
    };
    responses: {
      /** A list of transaction links */
      200: {
        'application/json': components['schemas']['TransactionLinkArray'];
      };
    };
  };
  /** Store a new link between two transactions. For this end point you need the journal_id from a transaction. */
  storeTransactionLink: {
    requestBody: {
      'application/json': components['schemas']['TransactionLink'];
      'application/x-www-form-urlencoded': components['schemas']['TransactionLink'];
    };
    responses: {
      /** New transaction link stored, result in response. */
      200: {
        'application/json': components['schemas']['TransactionLinkSingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** Returns a single link by its ID. */
  getTransactionLink: {
    parameters: {
      path: {
        /** The ID of the transaction link. */
        id: number;
      };
    };
    responses: {
      /** The requested link */
      200: {
        'application/json': components['schemas']['TransactionLinkSingle'];
      };
      /** No such transaction link. */
      404: unknown;
    };
  };
  /** Will permanently delete link. Transactions remain. */
  deleteTransactionLink: {
    parameters: {
      path: {
        /** The ID of the transaction link. */
        id: number;
      };
    };
    responses: {
      /** Transaction link deleted */
      204: never;
      /** No such transaction link */
      404: unknown;
    };
  };
  /** Used to update a single existing link. */
  updateTransactionLink: {
    parameters: {
      path: {
        /** The ID of the transaction link. */
        id: number;
      };
    };
    requestBody: {
      'application/json': components['schemas']['TransactionLink'];
      'application/x-www-form-urlencoded': components['schemas']['TransactionLink'];
    };
    responses: {
      /** Updated link type stored, result in response */
      200: {
        'application/json': components['schemas']['TransactionLinkSingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** List all piggy banks. */
  listPiggyBank: {
    parameters: {
      query: {
        /** Page number. The default pagination is 50. */
        page?: number;
      };
    };
    responses: {
      /** A list of piggy banks */
      200: {
        'application/json': components['schemas']['PiggyBankArray'];
      };
    };
  };
  /** Creates a new piggy bank. The data required can be submitted as a JSON body or as a list of parameters. */
  storePiggyBank: {
    requestBody: {
      'application/json': components['schemas']['PiggyBank'];
      'application/x-www-form-urlencoded': components['schemas']['PiggyBank'];
    };
    responses: {
      /** New piggy bank stored, result in response. */
      200: {
        'application/json': components['schemas']['PiggyBankSingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** Get a single piggy bank. */
  getPiggyBank: {
    parameters: {
      path: {
        /** The ID of the piggy bank. */
        id: number;
      };
    };
    responses: {
      /** The requested piggy bank */
      200: {
        'application/json': components['schemas']['PiggyBankSingle'];
      };
      /** Piggy bank not found */
      404: unknown;
    };
  };
  /** Update existing piggy bank. */
  updatePiggyBank: {
    parameters: {
      path: {
        /** The ID of the piggy bank */
        id: number;
      };
    };
    requestBody: {
      'application/json': components['schemas']['PiggyBank'];
      'application/x-www-form-urlencoded': components['schemas']['PiggyBank'];
    };
    responses: {
      /** Updated piggy bank stored, result in response */
      200: {
        'application/json': components['schemas']['PiggyBankSingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** Delete a piggy bank. */
  deletePiggyBank: {
    parameters: {
      path: {
        /** The ID of the piggy bank. */
        id: number;
      };
    };
    responses: {
      /** Piggy bank deleted. */
      204: never;
      /** No such piggy bank */
      404: unknown;
    };
  };
  /** List all events linked to a piggy bank (adding and removing money). */
  listEventByPiggyBank: {
    parameters: {
      path: {
        /** The ID of the piggy bank */
        id: number;
      };
      query: {
        /** Page number. The default pagination is 50. */
        page?: number;
      };
    };
    responses: {
      /** A list of piggy bank related events */
      200: {
        'application/json': components['schemas']['PiggyBankEventArray'];
      };
    };
  };
  /** Lists all attachments. */
  listAttachmentByPiggyBank: {
    parameters: {
      path: {
        /** The ID of the piggy bank. */
        id: number;
      };
      query: {
        /** Page number. The default pagination is 50. */
        page?: number;
      };
    };
    responses: {
      /** A list of attachments */
      200: {
        'application/json': components['schemas']['AttachmentArray'];
      };
      /** No such piggy bank. */
      404: unknown;
    };
  };
  /** List all preferences of the user. */
  listPreference: {
    parameters: {
      query: {
        /** Page number. The default pagination is 50. */
        page?: number;
      };
    };
    responses: {
      /** A list of preferences. */
      200: {
        'application/json': components['schemas']['PreferenceArray'];
      };
    };
  };
  /** Return a single preference. */
  getPreference: {
    parameters: {
      path: {
        /** The name of the preference. */
        name: string;
      };
    };
    responses: {
      /** A single preference. */
      200: {
        'application/json': components['schemas']['PreferenceSingle'];
      };
    };
  };
  /** Update a user's preference. */
  updatePreference: {
    parameters: {
      path: {
        /** The name of the preference. Will always overwrite. Will be created if it does not exist. */
        name: string;
      };
    };
    requestBody: {
      'application/json': components['schemas']['Preference'];
      'application/x-www-form-urlencoded': components['schemas']['Preference'];
    };
    responses: {
      /** Updated preference. */
      200: {
        'application/json': components['schemas']['PreferenceSingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** List all recurring transactions. */
  listRecurrence: {
    parameters: {
      query: {
        /** Page number. The default pagination is 50. */
        page?: number;
      };
    };
    responses: {
      /** A list of recurring transactions. */
      200: {
        'application/json': components['schemas']['RecurrenceArray'];
      };
    };
  };
  /** Creates a new recurring transaction. The data required can be submitted as a JSON body or as a list of parameters. */
  storeRecurrence: {
    requestBody: {
      'application/json': components['schemas']['Recurrence'];
      'application/x-www-form-urlencoded': components['schemas']['Recurrence'];
    };
    responses: {
      /** New recurring transaction stored, result in response. */
      200: {
        'application/json': components['schemas']['RecurrenceSingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** Get a single recurring transaction. */
  getRecurrence: {
    parameters: {
      path: {
        /** The ID of the recurring transaction. */
        id: number;
      };
    };
    responses: {
      /** The requested recurring transaction */
      200: {
        'application/json': components['schemas']['RecurrenceSingle'];
      };
      /** Recurring transaction not found */
      404: unknown;
    };
  };
  /** Update existing recurring transaction. */
  updateRecurrence: {
    parameters: {
      path: {
        /** The ID of the recurring transaction. */
        id: number;
      };
    };
    requestBody: {
      'application/json': components['schemas']['Recurrence'];
      'application/x-www-form-urlencoded': components['schemas']['Recurrence'];
    };
    responses: {
      /** Updated recurring transaction stored, result in response */
      200: {
        'application/json': components['schemas']['RecurrenceSingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** Delete a recurring transaction. Transactions created will not be deleted. */
  deleteRecurrence: {
    parameters: {
      path: {
        /** The ID of the recurring transaction. */
        id: number;
      };
    };
    responses: {
      /** Recurring transaction deleted. */
      204: never;
      /** No such recurring transaction */
      404: unknown;
    };
  };
  /** List all transactions created by a recurring transaction, optionally limited to the date ranges specified. */
  listTransactionByRecurrence: {
    parameters: {
      path: {
        /** The ID of the recurring transaction. */
        id: number;
      };
      query: {
        /** Page number. The default pagination is 50. */
        page?: number;
        /** A date formatted YYYY-MM-DD. Both the start and end date must be present. */
        start?: string;
        /** A date formatted YYYY-MM-DD. Both the start and end date must be present. */
        end?: string;
        /** Optional filter on the transaction type(s) returned */
        type?: components['schemas']['TransactionTypeFilter'];
      };
    };
    responses: {
      /** A list of transactions */
      200: {
        'application/json': components['schemas']['TransactionArray'];
      };
    };
  };
  /** Triggers the recurring transactions, like a cron job would. If the schedule does not call for a new transaction to be created, nothing will happen. */
  triggerRecurrence: {
    responses: {
      /** Triggered. Due to the way it's fired (an asynchronous job), the result cannot be shown to you. */
      200: unknown;
      /** Not triggered (not yet due or unable to). */
      204: never;
    };
  };
  /** List all rule groups. */
  listRuleGroup: {
    parameters: {
      query: {
        /** Page number. The default pagination is 50 */
        page?: number;
      };
    };
    responses: {
      /** A list of rule groups. */
      200: {
        'application/json': components['schemas']['RuleGroupArray'];
      };
    };
  };
  /** Creates a new rule group. The data required can be submitted as a JSON body or as a list of parameters. */
  storeRuleGroup: {
    requestBody: {
      'application/json': components['schemas']['RuleGroup'];
      'application/x-www-form-urlencoded': components['schemas']['RuleGroup'];
    };
    responses: {
      /** New rule group stored, result in response. */
      200: {
        'application/json': components['schemas']['RuleGroupSingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** Get a single rule group. This does not include the rules. For that, see below. */
  getRuleGroup: {
    parameters: {
      path: {
        /** The ID of the rule group. */
        id: number;
      };
    };
    responses: {
      /** The requested rule group */
      200: {
        'application/json': components['schemas']['RuleGroupSingle'];
      };
      /** Rule group not found. */
      404: unknown;
    };
  };
  /** Update existing rule group. */
  updateRuleGroup: {
    parameters: {
      path: {
        /** The ID of the rule group. */
        id: number;
      };
    };
    requestBody: {
      'application/json': components['schemas']['RuleGroup'];
      'application/x-www-form-urlencoded': components['schemas']['RuleGroup'];
    };
    responses: {
      /** Updated rule group stored, result in response */
      200: {
        'application/json': components['schemas']['RuleGroupSingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** Delete a rule group. */
  deleteRuleGroup: {
    parameters: {
      path: {
        /** The ID of the rule group. */
        id: number;
      };
    };
    responses: {
      /** Rule group deleted. */
      204: never;
      /** No such rule group */
      404: unknown;
    };
  };
  /** Test which transactions would be hit by the rule group. No changes will be made. Limit the result if you want to. */
  testRuleGroup: {
    parameters: {
      path: {
        /** The ID of the rule group. */
        id: number;
      };
      query: {
        /** Page number. The default pagination is 50 items. */
        page?: number;
        /** A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. */
        start?: string;
        /** A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. */
        end?: string;
        /** Maximum number of transactions Firefly III will try. Don't set this too high, or it will take Firefly III very long to run the test. I suggest a max of 200. */
        search_limit?: number;
        /** Maximum number of transactions the rule group can actually trigger on, before Firefly III stops. I would suggest setting this to 10 or 15. Don't go above the user's page size, because browsing to page 2 or 3 of a test result would fire the test again, making any navigation efforts very slow. */
        triggered_limit?: number;
        /** Limit the testing of the rule group to these asset accounts. Only asset accounts will be accepted. Other types will be silently dropped. */
        accounts?: string;
      };
    };
    responses: {
      /** A list of transactions that would be changed by any of the rules of the rule group. No changes will be made. */
      200: {
        'application/json': components['schemas']['TransactionArray'];
      };
    };
  };
  /** List rules in this rule group. */
  listRuleByGroup: {
    parameters: {
      path: {
        /** The ID of the rule group. */
        id: number;
      };
      query: {
        /** Page number. The default pagination is 50. */
        page?: number;
      };
    };
    responses: {
      /** A list of rules. */
      200: {
        'application/json': components['schemas']['RuleArray'];
      };
    };
  };
  /** Fire the rule group on your transactions. Changes will be made by the rules in the rule group! Limit the result if you want to. */
  fireRuleGroup: {
    parameters: {
      path: {
        /** The ID of the rule group. */
        id: number;
      };
      query: {
        /** A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present. */
        start?: string;
        /** A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present. */
        end?: string;
        /** Limit the testing of the rule group to these asset accounts. Only asset accounts will be accepted. Other types will be silently dropped. */
        accounts?: string;
      };
    };
    responses: {
      /** The rules in the group are executed. Due to the setup of this function (asynchronous job execution) the result cannot be displayed. */
      204: never;
    };
  };
  /** List all rules. */
  listRule: {
    parameters: {
      query: {
        /** Page number. The default pagination is 50. */
        page?: number;
      };
    };
    responses: {
      /** A list of rules */
      200: {
        'application/json': components['schemas']['RuleArray'];
      };
    };
  };
  /** Creates a new rule. The data required can be submitted as a JSON body or as a list of parameters. */
  storeRule: {
    requestBody: {
      'application/json': components['schemas']['Rule'];
      'application/x-www-form-urlencoded': components['schemas']['Rule'];
    };
    responses: {
      /** New rule stored, result in response. */
      200: {
        'application/json': components['schemas']['RuleSingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** Get a single rule. */
  getRule: {
    parameters: {
      path: {
        /** The ID of the object.X */
        id: number;
      };
    };
    responses: {
      /** The requested rule */
      200: {
        'application/json': components['schemas']['RuleSingle'];
      };
      /** Rule not found */
      404: unknown;
    };
  };
  /** Update existing rule. */
  updateRule: {
    parameters: {
      path: {
        /** The ID of the object.X */
        id: number;
      };
    };
    requestBody: {
      'application/json': components['schemas']['Rule'];
      'application/x-www-form-urlencoded': components['schemas']['Rule'];
    };
    responses: {
      /** Updated rule stored, result in response */
      200: {
        'application/json': components['schemas']['RuleSingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** Delete an rule. */
  deleteRule: {
    parameters: {
      path: {
        /** The ID of the rule. */
        id: number;
      };
    };
    responses: {
      /** Rule deleted. */
      204: never;
      /** No such rule */
      404: unknown;
    };
  };
  /** Test which transactions would be hit by the rule. No changes will be made. Limit the result if you want to. */
  testRule: {
    parameters: {
      path: {
        /** The ID of the rule. */
        id: number;
      };
      query: {
        /** A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. */
        start?: string;
        /** A date formatted YYYY-MM-DD, to limit the transactions the test will be applied to. Both the start date and the end date must be present. */
        end?: string;
        /** Limit the testing of the rule to these asset accounts. Only asset accounts will be accepted. Other types will be silently dropped. */
        accounts?: string;
      };
    };
    responses: {
      /** A list of transactions that would be changed by the rule. No changes will be made. */
      200: {
        'application/json': components['schemas']['TransactionArray'];
      };
    };
  };
  /** Fire the rule group on your transactions. Changes will be made by the rules in the group! Limit the result if you want to. */
  fireRule: {
    parameters: {
      path: {
        /** The ID of the rule. */
        id: number;
      };
      query: {
        /** A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present. */
        start?: string;
        /** A date formatted YYYY-MM-DD, to limit the transactions the actions will be applied to. Both the start date and the end date must be present. */
        end?: string;
        /** Limit the testing of the rule to these asset accounts. Only asset accounts will be accepted. Other types will be silently dropped. */
        accounts?: string;
      };
    };
    responses: {
      /** The rules in the group are executed. Due to the setup of this function (asynchronous job execution) the result cannot be displayed. */
      204: never;
    };
  };
  /** Search for transactions */
  searchTransactions: {
    parameters: {
      query: {
        /** The query you wish to search for. */
        query: string;
        /** Page number. The default pagination is 50 */
        page?: number;
      };
    };
    responses: {
      /** A list of transactions. */
      200: {
        'application/json': components['schemas']['TransactionArray'];
      };
    };
  };
  /** Search for accounts */
  searchAccounts: {
    parameters: {
      query: {
        /** Page number. The default pagination is 50 */
        page?: number;
        /** The query you wish to search for. */
        query: string;
        /** The type of accounts you wish to limit the search to. */
        type: components['schemas']['AccountTypeFilter'];
        /** The account field(s) you want to search in. */
        field: components['schemas']['AccountSearchFieldFilter'];
      };
    };
    responses: {
      /** A list of accounts. */
      200: {
        'application/json': components['schemas']['AccountArray'];
      };
    };
  };
  /** Returns basic sums of the users data, like the net worth, spent and earned amounts. It is multi-currency, and is in Firefly III to populate the dashboard. */
  getBasicSummary: {
    parameters: {
      query: {
        /** A date formatted YYYY-MM-DD. */
        start: string;
        /** A date formatted YYYY-MM-DD. */
        end: string;
        /** A currency code like EUR or USD, to filter the result. */
        currency_code?: string;
      };
    };
    responses: {
      /** An array of sums. It depends on the user what you can expect to get back, so please check out the documentation and try this out on the demo site. */
      200: {
        'application/json': components['schemas']['BasicSummary'];
      };
    };
  };
  /** Returns a list of tags, which can be used to draw a basic tag cloud. */
  getTagCloud: {
    parameters: {
      query: {
        /** A date formatted YYYY-MM-DD. */
        start: string;
        /** A date formatted YYYY-MM-DD. */
        end: string;
      };
    };
    responses: {
      /** A tag cloud */
      200: {
        'application/json': components['schemas']['TagCloud'];
      };
    };
  };
  /** List all of the user's tags. */
  listTag: {
    parameters: {
      query: {
        /** Page number */
        page?: number;
      };
    };
    responses: {
      /** A list of tags */
      200: {
        'application/json': components['schemas']['TagArray'];
      };
    };
  };
  /** Creates a new tag. The data required can be submitted as a JSON body or as a list of parameters. */
  storeTag: {
    requestBody: {
      'application/json': components['schemas']['TagModel'];
      'application/x-www-form-urlencoded': components['schemas']['TagModel'];
    };
    responses: {
      /** New tag stored, result in response. */
      200: {
        'application/json': components['schemas']['TagSingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** Get a single tag. */
  getTag: {
    parameters: {
      path: {
        /** Either the tag itself or the tag ID. */
        tag: string;
      };
      query: {
        /** Page number */
        page?: number;
      };
    };
    responses: {
      /** The requested tag */
      200: {
        'application/json': components['schemas']['TagSingle'];
      };
      /** Tag not found */
      404: unknown;
    };
  };
  /** Update existing tag. */
  updateTag: {
    parameters: {
      path: {
        /** Either the tag itself or the tag ID. */
        tag: string;
      };
    };
    requestBody: {
      'application/json': components['schemas']['TagModel'];
      'application/x-www-form-urlencoded': components['schemas']['TagModel'];
    };
    responses: {
      /** Updated tag stored, result in response */
      200: {
        'application/json': components['schemas']['TagSingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** Delete an tag. */
  deleteTag: {
    parameters: {
      path: {
        /** Either the tag itself or the tag ID. */
        tag: string;
      };
    };
    responses: {
      /** Tag deleted. */
      204: never;
      /** No such tag */
      404: unknown;
    };
  };
  /** List all transactions with this tag. */
  listTransactionByTag: {
    parameters: {
      path: {
        /** Either the tag itself or the tag ID. */
        tag: string;
      };
      query: {
        /** Page number. The default pagination is 50. */
        page?: number;
        /** A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive). */
        start?: string;
        /** A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive). */
        end?: string;
        /** Optional filter on the transaction type(s) returned. */
        type?: components['schemas']['TransactionTypeFilter'];
      };
    };
    responses: {
      /** A list of transactions. */
      200: {
        'application/json': components['schemas']['TransactionArray'];
      };
    };
  };
  /** Lists all attachments. */
  listAttachmentByTag: {
    parameters: {
      path: {
        /** Either the tag itself or the tag ID. */
        tag: string;
      };
      query: {
        /** Page number. The default pagination is 50. */
        page?: number;
      };
    };
    responses: {
      /** A list of attachments */
      200: {
        'application/json': components['schemas']['AttachmentArray'];
      };
      /** No such tag. */
      404: unknown;
    };
  };
  /** List all the user's transactions. */
  listTransaction: {
    parameters: {
      query: {
        /** Page number. The default pagination is 50. */
        page?: number;
        /** A date formatted YYYY-MM-DD. This is the start date of the selected range (inclusive). */
        start?: string;
        /** A date formatted YYYY-MM-DD. This is the end date of the selected range (inclusive). */
        end?: string;
        /** Optional filter on the transaction type(s) returned. */
        type?: components['schemas']['TransactionTypeFilter'];
      };
    };
    responses: {
      /** A list of transactions. */
      200: {
        'application/json': components['schemas']['TransactionArray'];
      };
    };
  };
  /** Creates a new transaction. The data required can be submitted as a JSON body or as a list of parameters. */
  storeTransaction: {
    requestBody: {
      'application/json': components['schemas']['Transaction'];
      'application/x-www-form-urlencoded': components['schemas']['Transaction'];
    };
    responses: {
      /** New transaction stored(s), result in response. */
      200: {
        'application/json': components['schemas']['TransactionSingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** Get a single transaction. */
  getTransaction: {
    parameters: {
      path: {
        /** The ID of the transaction. */
        id: number;
      };
    };
    responses: {
      /** The requested transaction. */
      200: {
        'application/json': components['schemas']['TransactionSingle'];
      };
      /** Transaction not found. */
      404: unknown;
    };
  };
  /** Update an existing transaction. */
  updateTransaction: {
    parameters: {
      path: {
        /** The ID of the transaction. */
        id: number;
      };
    };
    requestBody: {
      'application/json': components['schemas']['Transaction'];
      'application/x-www-form-urlencoded': components['schemas']['Transaction'];
    };
    responses: {
      /** Updated transaction stored, result in response */
      200: {
        'application/json': components['schemas']['TransactionSingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** Delete a transaction. */
  deleteTransaction: {
    parameters: {
      path: {
        /** The ID of the transaction. */
        id: number;
      };
    };
    responses: {
      /** Transaction deleted. */
      204: never;
      /** No such transaction. */
      404: unknown;
    };
  };
  /** Lists all attachments. */
  listAttachmentByTransaction: {
    parameters: {
      path: {
        /** The ID of the transaction. */
        id: number;
      };
      query: {
        /** Page number. The default pagination is 50. */
        page?: number;
      };
    };
    responses: {
      /** A list of attachments */
      200: {
        'application/json': components['schemas']['AttachmentArray'];
      };
      /** No such transaction. */
      404: unknown;
    };
  };
  /** Lists all piggy bank events. */
  listEventByTransaction: {
    parameters: {
      path: {
        /** The ID of the transaction. */
        id: number;
      };
      query: {
        /** Page number. The default pagination is 50. */
        page?: number;
      };
    };
    responses: {
      /** A list of piggy bank events. */
      200: {
        'application/json': components['schemas']['PiggyBankEventArray'];
      };
      /** No such transaction. */
      404: unknown;
    };
  };
  /** Get a single transaction by underlying journal. */
  getTransactionByJournal: {
    parameters: {
      path: {
        /** The ID of the transaction journal. */
        id: number;
      };
    };
    responses: {
      /** The requested transaction. */
      200: {
        'application/json': components['schemas']['TransactionSingle'];
      };
      /** Transaction not found. */
      404: unknown;
    };
  };
  /** List all the users in this instance of Firefly III. */
  listUser: {
    parameters: {
      query: {
        /** The page number, if necessary. The default pagination is 50, so 50 users per page. */
        page?: number;
      };
    };
    responses: {
      /** A list of users. */
      200: {
        'application/json': components['schemas']['UserArray'];
      };
    };
  };
  /** Creates a new user. The data required can be submitted as a JSON body or as a list of parameters. The user will be given a random password, which they can reset using the "forgot password" function. */
  storeUser: {
    requestBody: {
      'application/json': components['schemas']['User'];
      'application/x-www-form-urlencoded': components['schemas']['User'];
    };
    responses: {
      /** New user stored, result in response. */
      200: {
        'application/json': components['schemas']['UserSingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** Gets all info of a single user. */
  getUser: {
    parameters: {
      path: {
        /** The user ID. */
        id: number;
      };
    };
    responses: {
      /** The requested user. */
      200: {
        'application/json': components['schemas']['UserSingle'];
      };
      /** User not found. */
      404: unknown;
    };
  };
  /** Update existing user. */
  updateUser: {
    parameters: {
      path: {
        /** The user ID. */
        id: number;
      };
    };
    requestBody: {
      'application/json': components['schemas']['User'];
      'application/x-www-form-urlencoded': components['schemas']['User'];
    };
    responses: {
      /** Updated user stored, result in response */
      200: {
        'application/json': components['schemas']['UserSingle'];
      };
      /** Validation errors (see body) */
      422: {
        'application/json': components['schemas']['ValidationError'];
      };
    };
  };
  /** Delete a user. You cannot delete the current user. */
  deleteUser: {
    parameters: {
      path: {
        /** The user ID. */
        id: number;
      };
    };
    responses: {
      /** User deleted. */
      204: never;
      /** No such user. */
      404: unknown;
      /** Error when deleting, or when it is the currently authenticated user. */
      500: unknown;
    };
  };
}

export interface components {
  schemas: {
    Account: {
      created_at?: string;
      updated_at?: string;
      name: string;
      /** Can only be one one these account types. import, initial-balance and reconciliation cannot be set manually. */
      type:
        | 'asset'
        | 'expense'
        | 'import'
        | 'revenue'
        | 'cash'
        | 'liability'
        | 'liabilities'
        | 'initial-balance'
        | 'reconciliation';
      iban?: string;
      bic?: string;
      account_number?: string;
      opening_balance?: string;
      opening_balance_date?: string;
      virtual_balance?: string;
      current_balance?: string;
      current_balance_date?: string;
      /** Use either currency_id or currency_code. Defaults to the user's default currency. */
      currency_id?: number;
      /** Use either currency_id or currency_code. Defaults to the user's default currency. */
      currency_code?: string;
      currency_symbol?: string;
      currency_decimal_places?: number;
      /** If omitted, defaults to true. */
      active?: boolean;
      /** Order of the account */
      order?: number;
      /** If omitted, defaults to true. */
      include_net_worth?: boolean;
      /** Is only mandatory when the type is asset. */
      account_role?:
        | 'defaultAsset'
        | 'sharedAsset'
        | 'savingAsset'
        | 'ccAsset'
        | 'cashWalletAsset';
      /** Mandatory when the account_role is ccAsset. Can only be monthlyFull. */
      credit_card_type?: 'monthlyFull' | null;
      /** Mandatory when the account_role is ccAsset. Moment at which CC payment installments are asked for by the bank. */
      monthly_payment_date?: string | null;
      /** Mandatory when type is liability. Specifies the exact type. */
      liability_type?: 'loan' | 'debt' | 'mortgage';
      /** Mandatory when type is liability. Amount of money in the liability. Must be positive. */
      liability_amount?: string;
      /** Mandatory when type is liability. Start date for the liability. */
      liability_start_date?: string;
      /** Mandatory when type is liability. Interest percentage. */
      interest?: string;
      /** Mandatory when type is liability. Period over which the interest is calculated. */
      interest_period?: 'daily' | 'monthly' | 'yearly';
      notes?: string;
    };
    AccountArray: {
      data: components['schemas']['AccountRead'][];
      meta: components['schemas']['Meta'];
    };
    AccountRead: {
      /** Immutable value */
      type: string;
      id: number;
      attributes: components['schemas']['Account'];
    };
    AccountSearchFieldFilter: 'all' | 'iban' | 'name' | 'number' | 'id';
    AccountSingle: {
      data: components['schemas']['AccountRead'];
    };
    AccountTypeFilter:
      | 'all'
      | 'asset'
      | 'cash'
      | 'expense'
      | 'revenue'
      | 'special'
      | 'hidden'
      | 'liability'
      | 'liabilities'
      | 'Default account'
      | 'Cash account'
      | 'Asset account'
      | 'Expense account'
      | 'Revenue account'
      | 'Initial balance account'
      | 'Beneficiary account'
      | 'Import account'
      | 'Reconciliation account'
      | 'Loan'
      | 'Debt'
      | 'Mortgage';
    AccountTypeProperty:
      | 'Default account'
      | 'Cash account'
      | 'Asset account'
      | 'Expense account'
      | 'Revenue account'
      | 'Initial balance account'
      | 'Beneficiary account'
      | 'Import account'
      | 'Reconciliation account'
      | 'Loan'
      | 'Debt'
      | 'Mortgage';
    Attachment: {
      created_at?: string;
      updated_at?: string;
      filename: string;
      /** The object class to which the attachment must be linked. */
      attachable_type: 'Bill' | 'TransactionJournal' | 'ImportJob';
      /** ID of the model this attachment is linked to. */
      attachable_id: number;
      /** MD5 hash of the file for basic duplicate detection. */
      md5?: string;
      download_uri?: string;
      upload_uri?: string;
      title?: string;
      notes?: string;
      mime?: string;
      size?: number;
    };
    AttachmentArray: {
      data: components['schemas']['AttachmentRead'][];
      meta: components['schemas']['Meta'];
    };
    AttachmentRead: {
      /** Immutable value */
      type: string;
      id: number;
      attributes: components['schemas']['Attachment'];
      links: components['schemas']['ObjectLink'];
    };
    AttachmentSingle: {
      data: components['schemas']['AttachmentRead'];
    };
    AutocompleteAccount: {
      id: number;
      /** Name of the account found by an auto-complete search. */
      name: string;
      /** Asset accounts and liabilities have a second field with the given date's account balance. */
      name_with_balance: string;
      /** Account type of the account found by the auto-complete search. */
      type: string;
      /** Currency ID for this account. */
      currency_id: number;
      /** Currency code for this account. */
      currency_code: string;
      currency_symbol: string;
      currency_decimal_places: number;
    };
    AutocompleteAccountArray: components['schemas']['AutocompleteAccount'][];
    AutocompleteBill: {
      id: number;
      /** Name of the bill found by an auto-complete search. */
      name: string;
    };
    AutocompleteBillArray: components['schemas']['AutocompleteBill'][];
    AutocompleteBudget: {
      id: number;
      /** Name of the budget found by an auto-complete search. */
      name: string;
    };
    AutocompleteBudgetArray: components['schemas']['AutocompleteBudget'][];
    AutocompleteCategory: {
      id: number;
      /** Name of the category found by an auto-complete search. */
      name: string;
    };
    AutocompleteCategoryArray: components['schemas']['AutocompleteCategory'][];
    AutocompleteCurrency: {
      id: number;
      /** Currency name. */
      name: string;
      /** Currency code for this account. */
      code: string;
      symbol: string;
      decimal_places: number;
    };
    AutocompleteCurrencyArray: components['schemas']['AutocompleteCurrency'][];
    AutocompleteCurrencyCode: {
      id: number;
      /** Currency name with the code between brackets. */
      name: string;
      /** Currency code for this account. */
      code: string;
      symbol: string;
      decimal_places: number;
    };
    AutocompleteCurrencyCodeArray: components['schemas']['AutocompleteCurrencyCode'][];
    AutocompleteObjectGroup: {
      id: number;
      /** Title of the object group found by an auto-complete search. */
      title: string;
      /** Title of the object group found by an auto-complete search. */
      name: string;
    };
    AutocompleteObjectGroupArray: components['schemas']['AutocompleteObjectGroup'][];
    AutocompletePiggy: {
      id: number;
      /** Name of the piggy bank found by an auto-complete search. */
      name: string;
      /** Currency ID for this piggy bank. */
      currency_id?: number;
      /** Currency code for this piggy bank. */
      currency_code?: string;
      currency_symbol?: string;
      currency_decimal_places?: number;
    };
    AutocompletePiggyArray: components['schemas']['AutocompletePiggy'][];
    AutocompletePiggyBalance: {
      id: number;
      /** Name of the piggy bank found by an auto-complete search. */
      name: string;
      /** Name of the piggy bank found by an auto-complete search with the current balance formatted nicely. */
      name_with_balance?: string;
      /** Currency ID for this piggy bank. */
      currency_id?: number;
      /** Currency code for this piggy bank. */
      currency_code?: string;
      currency_symbol?: string;
      currency_decimal_places?: number;
    };
    AutocompletePiggyBalanceArray: components['schemas']['AutocompletePiggyBalance'][];
    AutocompleteRule: {
      id: number;
      /** Name of the rule found by an auto-complete search. */
      name: string;
    };
    AutocompleteRuleArray: components['schemas']['AutocompleteRule'][];
    AutocompleteRuleGroup: {
      id: number;
      /** Name of the rule group found by an auto-complete search. */
      name: string;
    };
    AutocompleteRuleGroupArray: components['schemas']['AutocompleteRuleGroup'][];
    AutocompleteTag: {
      id: number;
      /** Name of the tag found by an auto-complete search. */
      name: string;
      /** Name of the tag found by an auto-complete search. */
      tag: string;
    };
    AutocompleteTagArray: components['schemas']['AutocompleteTag'][];
    AutocompleteTransaction: {
      id: number;
      /** Transaction description with ID */
      name: string;
      /** Transaction description with ID */
      description: string;
    };
    AutocompleteTransactionArray: components['schemas']['AutocompleteTransaction'][];
    AutocompleteTransactionID: {
      id: number;
      /** Transaction description with ID */
      name: string;
      /** Transaction description with ID */
      description: string;
    };
    AutocompleteTransactionIDArray: components['schemas']['AutocompleteTransactionID'][];
    AutocompleteTransactionType: {
      id: number;
      /** Type of the object found by an auto-complete search. */
      name: string;
      /** Name of the object found by an auto-complete search. */
      type: string;
    };
    AutocompleteTransactionTypeArray: components['schemas']['AutocompleteTransactionType'][];
    AvailableBudget: {
      created_at?: string;
      updated_at?: string;
      /** Use either currency_id or currency_code. */
      currency_id?: number;
      /** Use either currency_id or currency_code. */
      currency_code?: string;
      currency_symbol?: string;
      currency_decimal_places?: number;
      amount: string;
      /** Start date of the available budget. */
      start: string;
      /** End date of the available budget. */
      end: string;
      spent_in_budgets?: components['schemas']['BudgetSpent'][];
      spent_outside_budget?: components['schemas']['BudgetSpent'][];
    };
    AvailableBudgetArray: {
      data: components['schemas']['AvailableBudgetRead'][];
      meta: components['schemas']['Meta'];
    };
    AvailableBudgetRead: {
      /** Immutable value */
      type: string;
      id: number;
      attributes: components['schemas']['AvailableBudget'];
    };
    AvailableBudgetSingle: {
      data: components['schemas']['AvailableBudgetRead'];
    };
    BasicSummary: components['schemas']['BasicSummaryEntry'][];
    BasicSummaryEntry: {
      /** This is a reference to the type of info shared, not influenced by translations or user preferences. */
      key?: string;
      /** A translated title for the information shared. */
      title?: string;
      /** The amount as a float. */
      monetary_value?: number;
      /** The currency ID of the associated currency. */
      currency_id?: number;
      currency_code?: string;
      currency_symbol?: string;
      /** Number of decimals for the associated currency. */
      currency_decimal_places?: number;
      /** The amount formatted according to the users locale */
      value_parsed?: string;
      /** Reference to a font-awesome icon without the fa- part. */
      local_icon?: string;
      /** A short explanation of the amounts origin. Already formatted according to the locale of the user or translated, if relevant. */
      sub_title?: string;
    };
    Bill: {
      created_at?: string;
      updated_at?: string;
      /** Use either currency_id or currency_code */
      currency_id?: number;
      /** Use either currency_id or currency_code */
      currency_code?: string;
      currency_symbol?: string;
      currency_decimal_places?: number;
      name: string;
      amount_min: string;
      amount_max: string;
      date: string;
      /** How often the bill must be paid. */
      repeat_freq: 'weekly' | 'monthly' | 'quarterly' | 'half-year' | 'yearly';
      /** How often the bill must be skipped. 1 means a bi-monthly bill. */
      skip?: number;
      /** If the bill is active. */
      active?: boolean;
      notes?: string;
      /** When the bill is expected to be due. */
      next_expected_match?: string;
      /** The group ID of the group this object is part of. NULL if no group. */
      object_group_id?: number;
      /** The order of the group. At least 1, for the highest sorting. */
      object_group_order?: number;
      /** The name of the group. NULL if no group. */
      object_group_title?: string;
      /** Array of future dates when the bill is expected to be paid. Autogenerated. */
      pay_dates?: string[];
      /** Array of past transactions when the bill was paid. */
      paid_dates?: {
        /** Transaction group ID of the paid bill. */
        transaction_group_id?: number;
        /** Transaction journal ID of the paid bill. */
        transaction_journal_id?: number;
        /** Date the bill was paid. */
        date?: string;
      }[];
    };
    BillArray: {
      data: components['schemas']['BillRead'][];
      meta: components['schemas']['Meta'];
    };
    BillRead: {
      /** Immutable value */
      type: string;
      id: number;
      attributes: components['schemas']['Bill'];
    };
    BillSingle: {
      data: components['schemas']['BillRead'];
    };
    Budget: {
      created_at?: string;
      updated_at?: string;
      name: string;
      active?: boolean;
      order?: number;
      /** The type of auto-budget that Firefly III must create. */
      auto_budget_type?: 'reset' | 'rollover' | 'none';
      /** Use either currency_id or currency_code. Defaults to the user's default currency. */
      auto_budget_currency_id?: number;
      /** Use either currency_id or currency_code. Defaults to the user's default currency. */
      auto_budget_currency_code?: string;
      auto_budget_amount?: string;
      /** Period for the auto budget */
      auto_budget_period?:
        | 'daily'
        | 'weekly'
        | 'monthly'
        | 'quarterly'
        | 'half_year'
        | 'yearly';
      /** Information on how much was spent in this budget. Is only filled in when the start and end date are submitted. */
      spent?: components['schemas']['BudgetSpent'][];
    };
    BudgetArray: {
      data: components['schemas']['BudgetRead'][];
      meta: components['schemas']['Meta'];
    };
    BudgetLimit: {
      created_at?: string;
      updated_at?: string;
      /** Use either currency_id or currency_code. Defaults to the user's default currency. */
      currency_id?: number;
      /** Use either currency_id or currency_code. Defaults to the user's default currency. */
      currency_code?: string;
      currency_symbol?: string;
      currency_decimal_places?: number;
      /** The budget ID of the associated budget. */
      budget_id: number;
      /** Start date of the budget limit. */
      start: string;
      /** End date of the budget limit. */
      end: string;
      amount: string;
      spent?: components['schemas']['BudgetSpent'][];
    };
    BudgetLimitArray: {
      data: components['schemas']['BudgetLimitRead'][];
      meta: components['schemas']['Meta'];
    };
    BudgetLimitRead: {
      /** Immutable value */
      type: string;
      id: number;
      attributes: components['schemas']['BudgetLimit'];
    };
    BudgetLimitSingle: {
      data: components['schemas']['BudgetLimitRead'];
    };
    BudgetRead: {
      /** Immutable value */
      type: string;
      id: number;
      attributes: components['schemas']['Budget'];
    };
    BudgetSingle: {
      data: components['schemas']['BudgetRead'];
    };
    BudgetSpent: {
      /** The amount spent. */
      sum?: string;
      currency_id?: number;
      currency_code?: string;
      currency_symbol?: string;
      /** Number of decimals supported by the currency */
      currency_decimal_places?: number;
    };
    Category: {
      created_at?: string;
      updated_at?: string;
      name: string;
      notes?: string;
      spent?: components['schemas']['CategorySpent'][];
      earned?: components['schemas']['CategoryEarned'][];
    };
    CategoryArray: {
      data: components['schemas']['CategoryRead'][];
      meta: components['schemas']['Meta'];
    };
    CategoryEarned: {
      start?: string;
      end?: string;
      currency_id?: number;
      currency_code?: string;
      currency_symbol?: string;
      /** Number of decimals supported by the currency */
      currency_decimal_places?: number;
      /** The amount earned. */
      amount?: string;
    };
    CategoryRead: {
      /** Immutable value */
      type: string;
      id: number;
      attributes: components['schemas']['Category'];
    };
    CategorySingle: {
      data: components['schemas']['CategoryRead'];
    };
    CategorySpent: {
      start?: string;
      end?: string;
      currency_id?: number;
      currency_code?: string;
      currency_symbol?: string;
      /** Number of decimals supported by the currency */
      currency_decimal_places?: number;
      /** The amount spent. */
      amount?: string;
    };
    ChartBar: components['schemas']['ChartDataSet'][];
    ChartDataPoint: {
      /** The key is the label of the value, so for example: '2018-01-01' => 13 or 'Groceries' => -123. */
      key?: string;
    };
    ChartDataSet: {
      /** This is the title of the current set. It can refer to an account, a budget or another object (by name). */
      label?: string;
      /** The currency ID of the currency associated to the data in the entries. */
      currency_id?: number;
      currency_code?: string;
      currency_symbol?: string;
      /** Number of decimals for the currency associated to the data in the entries. */
      currency_decimal_places?: number;
      /** Indicated the type of chart that is expected to be rendered. You can safely ignore this if you want. */
      type?: string;
      /** Used to indicate the Y axis for this data set. Is usually between 0 and 1 (left and right side of the chart). */
      yAxisID?: number;
      /** The actual entries for this data set. They 'key' value is the label for the data point. The value is the actual (numerical) value. */
      entries?: components['schemas']['ChartDataPoint'][];
    };
    ChartLine: components['schemas']['ChartDataSet'][];
    Configuration: {
      data?: {
        is_demo_site?: boolean;
        /**
         * If the user has given permission to check for updates.
         * - null = never asked.
         * - -1 = never asked.
         * - 0 = no permission.
         * - 1 = permission
         */
        permission_update_check?: number | null;
        last_update_check?: string;
        /** Whether other users can register. */
        single_user_mode?: boolean;
      };
    };
    ConfigurationUpdate: {
      /** Can be a number or a boolean. This depends on the actual configuration value. */
      value: string;
    };
    Currency: {
      created_at?: string;
      updated_at?: string;
      /** defaults to true */
      enabled?: boolean;
      /** Make this currency the default currency. */
      default?: boolean;
      code: string;
      name: string;
      symbol: string;
      /** Supports 0-16 decimals. */
      decimal_places?: number;
    };
    CurrencyArray: {
      data: components['schemas']['CurrencyRead'][];
      meta: components['schemas']['Meta'];
      links: components['schemas']['PageLink'];
    };
    CurrencyRead: {
      /** Immutable value */
      type: string;
      id: number;
      attributes: components['schemas']['Currency'];
    };
    CurrencySingle: {
      data: components['schemas']['CurrencyRead'];
    };
    DataDestroyObject:
      | 'budgets'
      | 'bills'
      | 'piggy_banks'
      | 'rules'
      | 'recurring'
      | 'categories'
      | 'tags'
      | 'object_groups'
      | 'accounts'
      | 'asset_accounts'
      | 'expense_accounts'
      | 'revenue_accounts'
      | 'liabilities'
      | 'transactions'
      | 'withdrawals'
      | 'deposits'
      | 'transfers';
    ExchangeRate: {
      /** Immutable value */
      type?: string;
      id?: number;
      attributes?: {
        created_at?: string;
        updated_at?: string;
        from_currency_id?: number;
        from_currency_name?: string;
        from_currency_code?: string;
        from_currency_symbol?: string;
        from_currency_decimal_places?: number;
        to_currency_id?: number;
        to_currency_code?: string;
        to_currency_symbol?: string;
        to_currency_decimal_places?: number;
        date?: string;
        rate?: number;
        /** The amount in the "to"-currency, if provided in the request. */
        amount?: string;
      };
    };
    ExchangeRateArray: {
      data: components['schemas']['ExchangeRate'][];
      meta: components['schemas']['Meta'];
      links: components['schemas']['PageLink'];
    };
    ImportJob: {
      /** Immutable value */
      type?: string;
      id?: number;
      attributes?: {
        created_at?: string;
        updated_at?: string;
        /** ID of the tag related to the import job, if present. */
        tag_id?: number;
        /** Tag related to the import job, if present. */
        tag_tag?: string;
        /** Import job unique identifier. */
        key?: string;
        /** File type, if relevant. */
        file_type?: string;
        /** Import provider that did the import. */
        provider?: string;
        /** Status of import job. */
        status?: string;
        /** Current stage. */
        stage?: string;
        /** JSON string with job-specific configuration. */
        configuration?: string;
        /** JSON string with job-specific status. */
        extended_status?: string;
        /** JSON string with a count of transactions in the job. */
        transactions?: string;
        /** JSON string with a list of errors. */
        errors?: string;
      };
    };
    ImportJobArray: {
      data: components['schemas']['ImportJob'][];
      meta: components['schemas']['Meta'];
      links: components['schemas']['PageLink'];
    };
    ImportJobSingle: {
      data: components['schemas']['ImportJob'];
    };
    LinkType: {
      name: string;
      inward: string;
      outward: string;
      editable?: boolean;
    };
    LinkTypeArray: {
      data: components['schemas']['LinkTypeRead'][];
      meta: components['schemas']['Meta'];
      links: components['schemas']['PageLink'];
    };
    LinkTypeRead: {
      /** Immutable value */
      type: string;
      id: number;
      attributes: components['schemas']['LinkType'];
      links: components['schemas']['ObjectLink'];
    };
    LinkTypeSingle: {
      data: components['schemas']['LinkTypeRead'];
    };
    Meta: {
      pagination?: {
        total?: number;
        count?: number;
        per_page?: number;
        current_page?: number;
        total_pages?: number;
      };
    };
    ObjectLink: {
      '0'?: {
        rel?: string;
        uri?: string;
      };
      self?: string;
    };
    PageLink: {
      self?: string;
      first?: string;
      last?: string;
    };
    PiggyBank: {
      created_at?: string;
      updated_at?: string;
      name: string;
      /** The ID of the asset account this piggy bank is connected to. */
      account_id: number;
      /** The name of the asset account this piggy bank is connected to. */
      account_name?: string;
      currency_id?: number;
      currency_code?: string;
      currency_symbol?: string;
      /** Number of decimals supported by the currency */
      currency_decimal_places?: number;
      target_amount: string;
      percentage?: number;
      current_amount?: string;
      left_to_save?: number;
      save_per_month?: number;
      /** The date you started with this piggy bank. */
      start_date?: string;
      /** The date you intend to finish saving money. */
      target_date?: string;
      order?: number;
      active?: boolean;
      notes?: string;
      /** The group ID of the group this object is part of. NULL if no group. */
      object_group_id?: number;
      /** The order of the group. At least 1, for the highest sorting. */
      object_group_order?: number;
      /** The name of the group. NULL if no group. */
      object_group_title?: string;
    };
    PiggyBankArray: {
      data: components['schemas']['PiggyBankRead'][];
      meta: components['schemas']['Meta'];
      links: components['schemas']['PageLink'];
    };
    PiggyBankEvent: {
      created_at?: string;
      updated_at?: string;
      currency_id?: number;
      currency_code?: string;
      currency_symbol?: string;
      currency_decimal_places?: number;
      amount?: string;
      /** The journal associated with the event. */
      journal_id?: number;
      transaction_id?: number;
    };
    PiggyBankEventArray: {
      data: components['schemas']['PiggyBankEventRead'][];
      meta: components['schemas']['Meta'];
      links: components['schemas']['PageLink'];
    };
    PiggyBankEventRead: {
      /** Immutable value */
      type: string;
      id: number;
      attributes: components['schemas']['PiggyBankEvent'];
      links: components['schemas']['ObjectLink'];
    };
    PiggyBankRead: {
      /** Immutable value */
      type: string;
      id: number;
      attributes: components['schemas']['PiggyBank'];
      links: components['schemas']['ObjectLink'];
    };
    PiggyBankSingle: {
      data: components['schemas']['PiggyBankRead'];
    };
    Preference: {
      created_at?: string;
      updated_at?: string;
      name?: string;
      /** This field can also be an array */
      data: string;
    };
    PreferenceArray: {
      data: components['schemas']['PreferenceRead'][];
      meta: components['schemas']['Meta'];
      links: components['schemas']['PageLink'];
    };
    PreferenceRead: {
      /** Immutable value */
      type: string;
      id: number;
      attributes: components['schemas']['Preference'];
    };
    PreferenceSingle: {
      data: components['schemas']['PreferenceRead'];
    };
    Recurrence: {
      created_at?: string;
      updated_at?: string;
      type:
        | 'withdrawal'
        | 'transfer'
        | 'deposit'
        | 'opening-balance'
        | 'reconciliation';
      title: string;
      /** Not to be confused with the description of the actual transaction(s) being created. */
      description?: string;
      /** First time the recurring transaction will fire. Must be after today. */
      first_date: string;
      /** First time the recurring transaction will fire. Must be after today. */
      latest_date?: string;
      /** Date until the recurring transaction can fire. Use either this field or repetitions. */
      repeat_until?: string;
      /** Max number of created transactions. Use either this field or repeat_until. */
      nr_of_repetitions?: number;
      /** Whether or not to fire the rules after the creation of a transaction. */
      apply_rules?: boolean;
      /** If the recurrence is even active. */
      active?: boolean;
      notes?: string;
      repetitions?: components['schemas']['RecurrenceRepetition'][];
      transactions?: components['schemas']['RecurrenceTransaction'][];
    };
    RecurrenceArray: {
      data: components['schemas']['RecurrenceRead'][];
      meta: components['schemas']['Meta'];
      links: components['schemas']['PageLink'];
    };
    RecurrenceRead: {
      /** Immutable value */
      type: string;
      id: number;
      attributes: components['schemas']['Recurrence'];
      links: components['schemas']['ObjectLink'];
    };
    RecurrenceRepetition: {
      id?: number;
      created_at?: string;
      updated_at?: string;
      /** The type of the repetition. ndom means: the n-th weekday of the month, where you can also specify which day of the week. */
      type: 'daily' | 'weekly' | 'ndom' | 'monthly' | 'yearly';
      /**
       * Information that defined the type of repetition.
       * - For 'daily', this is empty.
       * - For 'weekly', it is day of the week between 1 and 7 (Monday - Sunday).
       * - For 'ndom', it is '1,2' or '4,5' or something else, where the first number is the week in the month, and the second number is the day in the week (between 1 and 7). '2,3' means: the 2nd Wednesday of the month
       * - For 'monthly' it is the day of the month (1 - 31)
       * - For yearly, it is a full date, ie '2018-09-17'. The year you use does not matter.
       */
      moment: string;
      /** How many occurrences to skip. 0 means skip nothing. 1 means every other. */
      skip?: number;
      /**
       * How to respond when the recurring transaction falls in the weekend. Possible values:
       * 1. Do nothing, just create it
       * 2. Create no transaction.
       * 3. Skip to the previous Friday.
       * 4. Skip to the next Monday.
       */
      weekend?: number;
      /** Auto-generated repetition description. */
      description?: string;
      /** Array of future dates when the repetition will apply to. Auto generated. */
      occurrences?: string[];
    };
    RecurrenceSingle: {
      data: components['schemas']['RecurrenceRead'];
    };
    RecurrenceTransaction: {
      description: string;
      /** Amount of the transaction. */
      amount: string;
      /** Foreign amount of the transaction. */
      foreign_amount?: string | null;
      /** Submit either a currency_id or a currency_code. */
      currency_id?: number;
      /** Submit either a currency_id or a currency_code. */
      currency_code?: string;
      currency_symbol?: string;
      /** Number of decimals in the currency */
      currency_decimal_places?: number;
      /** Submit either a foreign_currency_id or a foreign_currency_code, or neither. */
      foreign_currency_id?: number | null;
      /** Submit either a foreign_currency_id or a foreign_currency_code, or neither. */
      foreign_currency_code?: string | null;
      foreign_currency_symbol?: string | null;
      /** Number of decimals in the currency */
      foreign_currency_decimal_places?: number | null;
      /** The budget ID for this transaction. */
      budget_id?: number;
      /** The name of the budget to be used. If the budget name is unknown, the ID will be used or the value will be ignored. */
      budget_name?: string | null;
      /** Category ID for this transaction. */
      category_id?: number;
      /** Category name for this transaction. */
      category_name?: string;
      /** ID of the source account. Submit either this or source_name. */
      source_id?: number;
      /** Name of the source account. Submit either this or source_id. */
      source_name?: string;
      source_iban?: string | null;
      source_type?: components['schemas']['AccountTypeProperty'];
      /** ID of the destination account. Submit either this or destination_name. */
      destination_id?: number;
      /** Name of the destination account. Submit either this or destination_id. */
      destination_name?: string;
      destination_iban?: string | null;
      destination_type?: components['schemas']['AccountTypeProperty'];
      /** Array of tags. */
      tags?: string[] | null;
      /** Optional. Use either this or the piggy_bank_name */
      piggy_bank_id?: number;
      /** Optional. Use either this or the piggy_bank_id */
      piggy_bank_name?: string;
    };
    Rule: {
      created_at?: string;
      updated_at?: string;
      title: string;
      description?: string;
      /** ID of the rule group under which the rule must be stored. Either this field or rule_group_title is mandatory. */
      rule_group_id: number;
      /** Title of the rule group under which the rule must be stored. Either this field or rule_group_id is mandatory. */
      rule_group_title?: string;
      order?: number;
      /** Which action is necessary for the rule to fire? Use either store-journal or update-journal. */
      trigger: 'store-journal' | 'update-journal';
      /** Whether or not the rule is even active. Default is true. */
      active?: boolean;
      /** If the rule is set to be strict, ALL triggers must hit in order for the rule to fire. Otherwise, just one is enough. Default value is true. */
      strict?: boolean;
      /** If this value is true and the rule is triggered, other rules  after this one in the group will be skipped. Default value is false. */
      stop_processing?: boolean;
      triggers: components['schemas']['RuleTrigger'][];
      actions: components['schemas']['RuleAction'][];
    };
    RuleAction: {
      id?: number;
      created_at?: string;
      updated_at?: string;
      /** The type of thing this action will do. A limited set is possible. */
      type:
        | 'user_action'
        | 'set_category'
        | 'clear_category'
        | 'set_budget'
        | 'clear_budget'
        | 'add_tag'
        | 'remove_tag'
        | 'remove_all_tags'
        | 'set_description'
        | 'append_description'
        | 'prepend_description'
        | 'set_source_account'
        | 'set_destination_account'
        | 'set_notes'
        | 'append_notes'
        | 'prepend_notes'
        | 'clear_notes'
        | 'link_to_bill'
        | 'convert_withdrawal'
        | 'convert_deposit'
        | 'convert_transfer';
      /** The accompanying value the action will set, change or update. Can be empty, but for some types this value is mandatory. */
      value: string | null;
      /** Order of the action */
      order?: number;
      /** If the action is active. */
      active?: boolean;
      /** When true, other actions will not be fired after this action has fired. */
      stop_processing?: boolean;
    };
    RuleArray: {
      data: components['schemas']['RuleRead'][];
      meta: components['schemas']['Meta'];
      links: components['schemas']['PageLink'];
    };
    RuleGroup: {
      created_at?: string;
      updated_at?: string;
      title: string;
      description?: string;
      order?: number;
      active?: boolean;
    };
    RuleGroupArray: {
      data: components['schemas']['RuleGroupRead'][];
      meta: components['schemas']['Meta'];
      links: components['schemas']['PageLink'];
    };
    RuleGroupRead: {
      /** Immutable value */
      type: string;
      id: number;
      attributes: components['schemas']['RuleGroup'];
      links: components['schemas']['ObjectLink'];
    };
    RuleGroupSingle: {
      data: components['schemas']['RuleGroupRead'];
    };
    RuleRead: {
      /** Immutable value */
      type: string;
      id: number;
      attributes: components['schemas']['Rule'];
      links: components['schemas']['ObjectLink'];
    };
    RuleSingle: {
      data: components['schemas']['RuleRead'];
    };
    RuleTrigger: {
      id?: number;
      created_at?: string;
      updated_at?: string;
      /** The type of thing this trigger responds to. A limited set is possible */
      type:
        | 'from_account_starts'
        | 'from_account_ends'
        | 'from_account_is'
        | 'from_account_contains'
        | 'to_account_starts'
        | 'to_account_ends'
        | 'to_account_is'
        | 'to_account_contains'
        | 'amount_less'
        | 'amount_exactly'
        | 'amount_more'
        | 'description_starts'
        | 'description_ends'
        | 'description_contains'
        | 'description_is'
        | 'transaction_type'
        | 'category_is'
        | 'budget_is'
        | 'tag_is'
        | 'currency_is'
        | 'has_attachments'
        | 'has_no_category'
        | 'has_any_category'
        | 'has_no_budget'
        | 'has_any_budget'
        | 'has_no_tag'
        | 'has_any_tag'
        | 'notes_contain'
        | 'notes_start'
        | 'notes_end'
        | 'notes_are'
        | 'no_notes'
        | 'any_notes';
      /** The accompanying value the trigger responds to. This value is often mandatory, but this depends on the trigger. */
      value: string;
      /** Order of the trigger */
      order?: number;
      /** If the trigger is active. */
      active?: boolean;
      /** When true, other triggers will not be checked if this trigger was triggered. */
      stop_processing?: boolean;
    };
    SystemInfo: {
      data: {
        version: string;
        api_version: string;
        php_version: string;
        os: string;
        driver: string;
      };
    };
    TagArray: {
      data: components['schemas']['TagRead'][];
      meta: components['schemas']['Meta'];
      links: components['schemas']['PageLink'];
    };
    TagCloud: {
      tags?: components['schemas']['TagCloudTag'][];
    };
    TagCloudTag: {
      /** The tag */
      tag?: string;
      /** ID of the tag */
      id?: number;
      /** The total amount of money related to this tag. There is no currency information available, and this is a basic sum of all amounts added together. */
      size?: number;
      /** A number between 0 and 1. 1 is given to the largest tag in the tag cloud, and 0 to the smallest. The rest are given a number between 0 and 1, related to their size in comparison to the largest tag. */
      relative?: number;
    };
    TagModel: {
      created_at?: string;
      updated_at?: string;
      /** The tag */
      tag: string;
      /** The date to which the tag is applicable. */
      date?: string | null;
      description?: string;
      /** Latitude of the tag's location, if applicable. Can be used to draw a map. */
      latitude?: number | null;
      /** Latitude of the tag's location, if applicable. Can be used to draw a map. */
      longitude?: number | null;
      /** Zoom level for the map, if drawn. This to set the box right. Unfortunately this is a proprietary value because each map provider has different zoom levels. */
      zoom_level?: number | null;
    };
    TagRead: {
      /** Immutable value */
      type: string;
      id: number;
      attributes: components['schemas']['TagModel'];
      links: components['schemas']['ObjectLink'];
    };
    TagSingle: {
      data: components['schemas']['TagRead'];
    };
    Transaction: {
      created_at?: string;
      updated_at?: string;
      /** User ID */
      user?: number;
      /** Break if the submitted transaction exists already. */
      error_if_duplicate_hash?: boolean;
      /** Whether or not to apply rules when submitting transaction. */
      apply_rules?: boolean;
      /** Title of the transaction if it has been split in more than one piece. Empty otherwise. */
      group_title?: string;
      transactions: components['schemas']['TransactionSplit'][];
    };
    TransactionArray: {
      data: components['schemas']['TransactionRead'][];
      meta: components['schemas']['Meta'];
      links: components['schemas']['PageLink'];
    };
    TransactionLink: {
      created_at?: string;
      updated_at?: string;
      /** The link type ID to use. You can also use the link_type_name field. */
      link_type_id: number;
      /** The link type name to use. You can also use the link_type_id field. */
      link_type_name?: string;
      /** The inward transaction transaction_journal_id for the link. This becomes the 'is paid by' transaction of the set. */
      inward_id: number;
      /** The outward transaction transaction_journal_id for the link. This becomes the 'pays for' transaction of the set. */
      outward_id: number;
      /** Optional. Some notes. */
      notes?: string;
    };
    TransactionLinkArray: {
      data: components['schemas']['TransactionLinkRead'][];
      meta: components['schemas']['Meta'];
      links: components['schemas']['PageLink'];
    };
    TransactionLinkRead: {
      /** Immutable value */
      type: string;
      id: number;
      attributes: components['schemas']['TransactionLink'];
      links: components['schemas']['ObjectLink'];
    };
    TransactionLinkSingle: {
      data: components['schemas']['TransactionLinkRead'];
    };
    TransactionRead: {
      /** Immutable value */
      type: string;
      id: number;
      attributes: components['schemas']['Transaction'];
      links: components['schemas']['ObjectLink'];
    };
    TransactionSingle: {
      data: components['schemas']['TransactionRead'];
    };
    TransactionSplit: {
      /** User ID */
      user?: number;
      /**
       * ID of the underlying transaction journal. Each transaction consists of a transaction group (see the top ID) and one or more journals
       * making up the splits of the transaction.
       */
      transaction_journal_id?: number;
      /** Type of transaction. */
      type:
        | 'withdrawal'
        | 'deposit'
        | 'transfer'
        | 'reconciliation'
        | 'opening balance';
      /** Date of the transaction */
      date: string;
      /** Amount of the transaction. */
      amount: string;
      /** Description of the transaction. */
      description: string;
      /** Order of this entry in the list of transactions. */
      order?: number | null;
      /** Currency ID. Default is the source account's currency, or the user's default currency. Can be used instead of currency_code. */
      currency_id?: number | null;
      /** Currency code. Default is the source account's currency, or the user's default currency. Can be used instead of currency_id. */
      currency_code?: string | null;
      currency_symbol?: string;
      currency_name?: string;
      /** Number of decimals used in this currency. */
      currency_decimal_places?: number;
      /** The amount in a foreign currency. */
      foreign_amount?: string | null;
      /** Currency ID of the foreign currency. Default is null. Is required when you submit a foreign amount. */
      foreign_currency_id?: number | null;
      /** Currency code of the foreign currency. Default is NULL. Can be used instead of the foreign_currency_id, but this or the ID is required when submitting a foreign amount. */
      foreign_currency_code?: string | null;
      foreign_currency_symbol?: string | null;
      /** Number of decimals in the currency */
      foreign_currency_decimal_places?: number | null;
      /** The budget ID for this transaction. */
      budget_id?: number | null;
      /** The name of the budget to be used. If the budget name is unknown, the ID will be used or the value will be ignored. */
      budget_name?: string | null;
      /** The category ID for this transaction. */
      category_id?: number | null;
      /** The name of the category to be used. If the category is unknown, it will be created. If the ID and the name point to different categories, the ID overrules the name. */
      category_name?: string;
      /** ID of the source account. For a withdrawal or a transfer, this must always be an asset account. For deposits, this must be a revenue account. */
      source_id: number | null;
      /** Name of the source account. For a withdrawal or a transfer, this must always be an asset account. For deposits, this must be a revenue account. Can be used instead of the source_id. If the transaction is a deposit, the source_name can be filled in freely: the account will be created based on the name. */
      source_name?: string | null;
      source_iban?: string | null;
      source_type?: components['schemas']['AccountTypeProperty'];
      /** ID of the destination account. For a deposit or a transfer, this must always be an asset account. For withdrawals this must be an expense account. */
      destination_id: number | null;
      /** Name of the destination account. You can submit the name instead of the ID. For everything except transfers, the account will be auto-generated if unknown, so submitting a name is enough. */
      destination_name?: string | null;
      destination_iban?: string | null;
      destination_type?: components['schemas']['AccountTypeProperty'];
      /** If the transaction has been reconciled already. When you set this, the amount can no longer be edited by the user. */
      reconciled?: boolean;
      /** Optional. Use either this or the piggy_bank_name */
      piggy_bank_id?: number;
      /** Optional. Use either this or the piggy_bank_id */
      piggy_bank_name?: string;
      /** Optional. Use either this or the bill_name */
      bill_id?: number | null;
      /** Optional. Use either this or the bill_id */
      bill_name?: string | null;
      /** Array of tags. */
      tags?: string[] | null;
      notes?: string | null;
      /** Reference to internal reference of other systems. */
      internal_reference?: string | null;
      /** Reference to external ID in other systems. */
      external_id?: string | null;
      /** System generated identifier for original creator of transaction. */
      original_source?: string | null;
      /** Reference to recurrence that made the transaction. */
      recurrence_id?: number | null;
      /** Total number of transactions expected to be created by this recurrence repetition. Will be 0 if infinite. */
      recurrence_total?: number;
      /** The # of the current transaction created under this recurrence. */
      recurrence_count?: number;
      /** Internal ID of bunq transaction. */
      bunq_payment_id?: string | null;
      /** Hash value of original import transaction (for duplicate detection). */
      import_hash_v2?: string | null;
      /** SEPA Clearing Code */
      sepa_cc?: string | null;
      /** SEPA Opposing Account Identifier */
      sepa_ct_op?: string;
      /** SEPA end-to-end Identifier */
      sepa_ct_id?: string | null;
      /** SEPA mandate identifier */
      sepa_db?: string | null;
      /** SEPA Country */
      sepa_country?: string | null;
      /** SEPA External Purpose indicator */
      sepa_ep?: string | null;
      /** SEPA Creditor Identifier */
      sepa_ci?: string | null;
      /** SEPA Batch ID */
      sepa_batch_id?: string | null;
      interest_date?: string | null;
      book_date?: string | null;
      process_date?: string | null;
      due_date?: string | null;
      payment_date?: string | null;
      invoice_date?: string | null;
    };
    TransactionTypeFilter:
      | 'all'
      | 'withdrawal'
      | 'withdrawals'
      | 'expense'
      | 'deposit'
      | 'deposits'
      | 'income'
      | 'transfer'
      | 'transfers'
      | 'opening_balance'
      | 'reconciliation'
      | 'special'
      | 'specials'
      | 'default';
    User: {
      created_at?: string;
      updated_at?: string;
      /** The new users email address. */
      email: string;
      /** Boolean to indicate if the user is blocked. */
      blocked?: boolean;
      /** If you say the user must be blocked, this will be the reason code. */
      blocked_code?: 'email_changed' | null;
      /** Role for the new user. Can be empty or omitted. */
      role?: ('owner' | 'demo') | null;
    };
    UserArray: {
      data: components['schemas']['UserRead'][];
      meta: components['schemas']['Meta'];
      links: components['schemas']['PageLink'];
    };
    UserRead: {
      /** Immutable value */
      type: string;
      id: number;
      attributes: components['schemas']['User'];
      links: components['schemas']['ObjectLink'];
    };
    UserSingle: {
      data: components['schemas']['UserRead'];
    };
    ValidationError: {
      message?: string;
      errors?: {
        field1?: string[];
        field2?: string[];
      };
    };
  };
}
